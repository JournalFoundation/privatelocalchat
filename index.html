<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Private Local Chat</title>
  <style>
    /* Minimal styling for the chat client UI. */

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #fff;
      color: #222;
      min-height: 100vh;
    }

    #app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Sidebar styling */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(85vw, 320px);
      background: #f4f4f4;
      border-right: 1px solid #ddd;
      box-shadow: 2px 0 12px rgba(0, 0, 0, 0.15);
      padding: 16px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.25s ease;
      z-index: 1001;
    }

    body.sidebar-open .sidebar {
      transform: translateX(0);
    }

    body.sidebar-open {
      overflow: hidden;
    }

    .sidebar h2,
    .sidebar h3 {
      margin-top: 0;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      gap: 8px;
    }

    .sidebar-close {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #333;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .secret-field {
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 8px;
      align-items: center;
    }

    .secret-input {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    }

    .secret-input.masked {
      -webkit-text-security: disc;
    }

    .hint-text {
      margin-top: -4px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #555;
    }

    .hint-text a {
      color: inherit;
      text-decoration: underline;
    }

    .link-btn {
      border: none;
      background: transparent;
      color: #007bff;
      padding: 0;
      font: inherit;
      text-decoration: underline;
      cursor: pointer;
    }

    .link-btn:hover {
      color: #0056b3;
    }

    .link-btn:focus-visible {
      outline: 2px solid #0056b3;
      outline-offset: 2px;
    }

    .form-group button {
      width: 100%;
      padding: 8px;
      background: #007bff;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .form-group button:hover {
      background: #0056b3;
    }

    .threads-header {
      margin-top: 16px;
    }

    .threads-header h3 {
      margin: 0 0 12px 0;
    }

    .thread-list {
      list-style: none;
      padding: 0;
      margin: 0;
      flex: 1;
      overflow-y: auto;
    }

    .thread-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 4px;
    }

    .thread-list li.selected {
      background: #007bff;
      color: #fff;
    }

    .thread-list li:hover {
      background: #e2e6ea;
    }

    .thread-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .thread-menu-btn {
      border: none;
      background: transparent;
      color: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px 4px;
    }

    .thread-menu-btn .icon {
      width: 16px;
      height: 16px;
    }

    .thread-menu-btn:hover {
      color: #007bff;
    }

    .thread-list li.selected .thread-menu-btn:hover {
      color: #cfe2ff;
    }

    .thread-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      padding: 4px 0;
      min-width: 140px;
      z-index: 1101;
    }

    .thread-menu button {
      width: 100%;
      background: none;
      border: none;
      text-align: left;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .thread-menu button:hover {
      background: #f0f0f0;
    }

    .thread-menu button.delete {
      color: #c1121f;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
      font-size: 0.9rem;
      color: #333;
    }

    .action-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .action-label {
      font-weight: 600;
    }

    .qr-preview {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      margin: 16px 0 8px;
    }

    .qr-code {
      background: #fff;
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .qr-code canvas,
    .qr-code img {
      display: block;
      width: 100%;
      height: auto;
    }

    .qr-link {
      word-break: break-all;
      text-align: center;
      font-size: 0.85rem;
      color: #333;
    }

    .icon {
      width: 18px;
      height: 18px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 18px;
      fill: currentColor;
      color: currentColor;
    }

    .icon + span {
      margin-left: 6px;
    }

    .btn-label {
      display: inline-flex;
      align-items: center;
    }

    .icon-btn {
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 4px;
      padding: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
      color: #333;
    }

    .icon-btn:hover {
      background: #e2e6ea;
      border-color: #b3b3b3;
    }

    .icon-btn:focus {
      outline: 2px solid #0056b3;
      outline-offset: 2px;
    }

    .icon-btn .icon {
      width: 18px;
      height: 18px;
    }

    .highlight-pulse {
      box-shadow: 0 0 0 4px rgba(0, 123, 255, 0.35);
      border-radius: 4px;
      transition: box-shadow 0.25s ease;
    }

    .thread-list li.new-thread-item {
      display: block;
      padding: 0;
      background: none;
      margin-bottom: 8px;
    }

    .thread-list li.new-thread-item:hover {
      background: none;
    }

    .new-thread-button {
      width: 100%;
      border: none;
      background: #28a745;
      color: #fff;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .new-thread-button:hover {
      background: #1c7e32;
    }

    .model-select-row button {
      width: 100%;
      padding: 8px;
      font-size: 0.9rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .model-select-row button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .model-select-row select {
      width: 100%;
      margin-top: 8px;
    }

    /* Chat area styling */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-bottom: 1px solid #ddd;
    }

    .thread-title {
      flex: 1;
      font-size: 1.1rem;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    /* === Promo banner (minimal, mobile-first) === */
    .promo-banner {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 12px;
      background: #fff8e1;
      border-bottom: 1px solid #f0c36d;
      color: #7a5200;
      font-size: 0.9rem;
    }

    .promo-banner[hidden] {
      display: none;
    }

    .promo-banner a {
      color: #7a5200;
      text-decoration: underline;
    }

    .promo-banner .dismiss {
      border: none;
      background: transparent;
      cursor: pointer;
      color: #7a5200;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
    }

    /* Info button in header */
    .about-btn {
      width: 44px;
      height: 44px;
      border: 2px solid #007bff;
      border-radius: 50%;
      background: #fff;
      color: #007bff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
    }

    .about-btn .icon {
      width: 20px;
      height: 20px;
    }

    .about-btn:focus-visible {
      outline: 3px solid #80bdff;
      outline-offset: 2px;
    }

    /* === Bottom-sheet modal === */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1000;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1001;
    }

    .modal[hidden],
    .modal-backdrop[hidden] {
      display: none !important;
    }

    .modal .sheet {
      width: 100%;
      max-height: 85vh;
      overflow: auto;
      background: #fff;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      box-shadow: 0 -6px 24px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    .modal .modal-close {
      position: absolute;
      right: 16px;
      top: 12px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
    }

    .modal h2 {
      margin-top: 4px;
    }

    .modal .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 12px 0;
    }

    .modal .cta-link {
      display: inline-flex;
      align-items: center;
      padding: 8px 10px;
      border-radius: 6px;
      background: #f1f3f5;
      color: #0a58ca;
      text-decoration: none;
      gap: 6px;
    }

    .modal .primary,
    .modal .secondary {
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #ccc;
      cursor: pointer;
      background: #fff;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .modal .primary {
      background: #0d6efd;
      color: #fff;
      border-color: #0d6efd;
    }

    .modal .secondary {
      background: #fff;
      color: #0d6efd;
      border-color: #0d6efd;
    }

    .modal .fine-print {
      color: #666;
      font-size: 0.85rem;
    }

    /* Desktop: center the dialog instead of bottom sheet */
    @media (min-width: 900px) {
      .modal {
        align-items: center;
      }

      .modal .sheet {
        max-width: 720px;
        border-radius: 12px;
        padding: 20px 24px;
      }
    }

    .system-prompt-container {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }

    .system-prompt-container label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #555;
    }

    .system-prompt-container textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .messages {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      background: #fafafa;
    }

    .message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user {
      background: #e9f7ef;
      align-self: flex-end;
    }

    .message.assistant {
      background: #f1f1f1;
      align-self: flex-start;
    }

    .message.system {
      background: #fffbe6;
      border: 1px dashed #ccc;
    }

    .message-form {
      display: flex;
      padding: 12px;
      border-top: 1px solid #ddd;
      background: #f8f9fa;
    }

    .message-form textarea {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      font-size: 0.9rem;
      min-height: 60px;
    }

    .message-form button {
      margin-left: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      font-size: 0.9rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .message-form button:hover {
      background: #0056b3;
    }

    .message-form button:disabled {
      background: #94b9e8;
      cursor: not-allowed;
    }

    .message-form textarea:disabled {
      background: #e9ecef;
      cursor: not-allowed;
    }

    .message-form.disabled {
      opacity: 0.7;
    }

    .message-input-wrapper {
      position: relative;
      flex: 1;
      display: flex;
    }

    .message-input-wrapper textarea {
      flex: 1;
      width: 100%;
    }

    .message-input-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .message-form.disabled .message-input-overlay {
      pointer-events: auto;
      cursor: not-allowed;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translate(-50%, 100%);
      background: rgba(34, 34, 34, 0.92);
      color: #fff;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      opacity: 0;
      transition: opacity 0.18s ease, transform 0.18s ease;
      z-index: 2000;
      max-width: min(90vw, 320px);
      text-align: center;
    }

    .toast.visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    @media (prefers-reduced-motion: reduce) {
      .toast {
        transition: none;
      }
    }

    .chat-notice {
      display: none;
      padding: 12px;
      background: #fff3cd;
      border-bottom: 1px solid #f7d070;
      color: #6c4a00;
      font-size: 0.9rem;
    }

    .chat-notice.active {
      display: block;
    }

    .chat-notice.requires-endpoint {
      cursor: pointer;
    }

    .chat-notice.requires-endpoint:focus-visible {
      outline: 2px solid #f7d070;
      outline-offset: 2px;
    }

    .chat-notice ul {
      margin: 0;
      padding-left: 20px;
    }

    .chat-notice p {
      margin: 0 0 8px;
    }

    .notice-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .notice-actions button {
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 0.85rem;
      cursor: pointer;
      background: #007bff;
      color: #fff;
    }

    .notice-actions button.secondary {
      background: #6c757d;
    }

    .notice-actions button:focus-visible {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    /* Loading indicator styling */
    .loading {
      display: inline-block;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #007bff;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    .mobile-toggle {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 4px 6px;
      color: #007bff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-toggle:focus,
    .sidebar-close:focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }

    #sidebarOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 1000;
    }

    body.sidebar-open #sidebarOverlay {
      opacity: 1;
      pointer-events: auto;
    }

    @media (min-width: 900px) {
      #app {
        flex-direction: row;
        min-height: 100vh;
      }

      .sidebar {
        position: relative;
        transform: none;
        width: 300px;
        max-width: 300px;
        box-shadow: none;
      }

      body.sidebar-open {
        overflow: auto;
      }

      #sidebarOverlay,
      .mobile-toggle,
      .sidebar-close {
        display: none;
      }

      .chat-area {
        padding-left: 0;
        min-height: 100vh;
      }
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <!-- Inline SVG sprite sheet for local icons -->
  <svg
    xmlns="http://www.w3.org/2000/svg"
    style="position: absolute; width: 0; height: 0; overflow: hidden"
    aria-hidden="true"
    focusable="false"
  >
    <symbol id="icon-import" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M3 13.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1 0-1zM7.25 1.5a.75.75 0 0 1 .75.75v5.69l2.22-2.22a.75.75 0 1 1 1.06 1.06l-3.5 3.5a.75.75 0 0 1-1.06 0l-3.5-3.5A.75.75 0 1 1 3.28 5.72L5.5 7.94V2.25a.75.75 0 0 1 .75-.75z"
      />
    </symbol>
    <symbol id="icon-export" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M3 13.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1 0-1zM8.75 8.81V2.25a.75.75 0 0 0-1.5 0v6.56L5.03 6.59a.75.75 0 1 0-1.06 1.06l3.5 3.5a.75.75 0 0 0 1.06 0l3.5-3.5a.75.75 0 1 0-1.06-1.06L8.75 8.81z"
      />
    </symbol>
    <symbol id="icon-info" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M8 1.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13zM8 4.25a.875.875 0 1 1 0 1.75.875.875 0 0 1 0-1.75zM7 7.75h2v5H7z"
      />
    </symbol>
    <symbol id="icon-github" viewBox="0 0 16 16" fill="currentColor">
      <path
        fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"
      />
    </symbol>
    <symbol id="icon-menu" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M1.75 3.5h12.5a.75.75 0 0 1 0 1.5H1.75a.75.75 0 0 1 0-1.5Zm0 3.75h12.5a.75.75 0 0 1 0 1.5H1.75a.75.75 0 0 1 0-1.5Zm0 3.75h12.5a.75.75 0 0 1 0 1.5H1.75a.75.75 0 0 1 0-1.5Z"
      />
    </symbol>
    <symbol id="icon-close" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.75.75 0 1 1 1.06 1.06L9.06 8l3.22 3.22a.75.75 0 1 1-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 1 1-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z"
      />
    </symbol>
    <symbol id="icon-download" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M8 1.25a.75.75 0 0 1 .75.75v6.19l2.22-2.22a.75.75 0 0 1 1.06 1.06l-3.5 3.5a.75.75 0 0 1-1.06 0l-3.5-3.5A.75.75 0 0 1 4.03 5.97L6.25 8.19V2a.75.75 0 0 1 .75-.75zM3 13.5h10a.5.5 0 0 1 0 1H3a.5.5 0 0 1 0-1z"
      />
    </symbol>
    <symbol id="icon-qr" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M2 2h4v4H2V2Zm1 1v2h2V3H3Zm6-1h4v4H9V2Zm1 1v2h2V3h-2ZM2 9h4v5H2V9Zm1 1v3h2v-3H3Zm6-1h2v2H9V9Zm3 0h2v2h-2V9Zm-3 3h2v2H9v-2Zm3 0h2v2h-2v-2Zm0 3h1v1h-1v-1Zm-3 0h1v1H9v-1Z"
      />
    </symbol>
    <symbol id="icon-plus" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M8 1a.75.75 0 0 1 .75.75v5.5h5.5a.75.75 0 0 1 0 1.5h-5.5v5.5a.75.75 0 0 1-1.5 0v-5.5h-5.5a.75.75 0 0 1 0-1.5h5.5v-5.5A.75.75 0 0 1 8 1z"
      />
    </symbol>
    <symbol id="icon-refresh" viewBox="0 0 16 16" fill="currentColor">
      <path
        fill-rule="evenodd"
        d="M8 3a5 5 0 1 0 4.546 2.914.75.75 0 1 1 1.363-.65A6.5 6.5 0 1 1 8 1.5V0l2.25 2.25L8 4.5V3z"
      />
    </symbol>
    <symbol id="icon-eye" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M8 3.25c3.33 0 6.2 2.15 7.12 4.69-.92 2.54-3.79 4.81-7.12 4.81S1.8 10.48.88 7.94C1.8 5.4 4.67 3.25 8 3.25zm0 1.5c-2.58 0-4.9 1.58-5.6 3.19.7 1.6 3.02 3.19 5.6 3.19s4.9-1.59 5.6-3.19C12.9 6.33 10.58 4.75 8 4.75z"
      />
      <path d="M8 6.25a1.75 1.75 0 1 0 0 3.5 1.75 1.75 0 0 0 0-3.5z" />
    </symbol>
    <symbol id="icon-eye-off" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M2.146 2.146a.5.5 0 0 1 .708 0l1.94 1.94C5.9 3.37 6.92 3.25 8 3.25c3.33 0 6.2 2.15 7.12 4.69a7.59 7.59 0 0 1-2.3 2.97l1.984 1.984a.5.5 0 0 1-.708.708l-2.04-2.04C10.8 12.42 9.44 12.75 8 12.75c-3.33 0-6.2-2.15-7.12-4.69a7.57 7.57 0 0 1 2.32-3.03L2.146 2.854a.5.5 0 0 1 0-.708z"
      />
      <path
        d="M6.28 6.28 8 8l1.72 1.72A1.75 1.75 0 0 1 6.28 6.28zm2.44-1.03a3.25 3.25 0 0 1 3.03 3.03.75.75 0 0 1-1.49.17 1.75 1.75 0 0 0-1.7-1.7.75.75 0 0 1 .16-1.5z"
      />
    </symbol>
    <symbol id="icon-copy" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M4.5 1A1.5 1.5 0 0 0 3 2.5v9A1.5 1.5 0 0 0 4.5 13H5V4.5A2.5 2.5 0 0 1 7.5 2h5A1.5 1.5 0 0 0 11 0.5h-6.5z"
      />
      <path
        d="M7.5 3A1.5 1.5 0 0 0 6 4.5v9A1.5 1.5 0 0 0 7.5 15h7a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 14.5 3h-7z"
      />
    </symbol>
    <symbol id="icon-more-vertical" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M8 3a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm0 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"
      />
    </symbol>
    <symbol id="icon-edit" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M12.854 1.146a.5.5 0 0 0-.708 0L5 8.293V11h2.707l7.146-7.146a.5.5 0 0 0 0-.708l-1-1a.5.5 0 0 0-.707 0z"
      />
      <path d="M4 12.5V8.707l-2 2V14h3.293l2-2H4.5a.5.5 0 0 1-.5-.5z" />
    </symbol>
    <symbol id="icon-trash" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M6.5 1a1.5 1.5 0 0 0-1.415 1H3a.75.75 0 0 0 0 1.5h10a.75.75 0 0 0 0-1.5h-2.085A1.5 1.5 0 0 0 9.5 1h-3zM4.5 5.5a.5.5 0 0 1 .5.5v6.75a1.75 1.75 0 0 0 1.75 1.75h2.5A1.75 1.75 0 0 0 11 12.75V6a.5.5 0 0 1 1 0v6.75A2.75 2.75 0 0 1 9.25 15.5h-2.5A2.75 2.75 0 0 1 4 12.75V6a.5.5 0 0 1 .5-.5z"
      />
      <path d="M6.75 6a.5.5 0 0 0-.5.5v6a.5.5 0 1 0 1 0v-6a.5.5 0 0 0-.5-.5zm2 0a.5.5 0 0 0-.5.5v6a.5.5 0 1 0 1 0v-6a.5.5 0 0 0-.5-.5z" />
    </symbol>
    <symbol id="icon-link" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M6.354 4.146a3.5 3.5 0 0 1 4.95 0l.55.55a3.5 3.5 0 0 1 0 4.95l-.707.707a.75.75 0 0 1-1.06-1.06l.707-.708a2 2 0 0 0 0-2.828l-.55-.55a2 2 0 0 0-2.828 0l-.708.707a.75.75 0 1 1-1.06-1.06l.707-.708z"
      />
      <path
        d="M9.646 11.854a3.5 3.5 0 0 1-4.95 0l-.55-.55a3.5 3.5 0 0 1 0-4.95l.707-.707a.75.75 0 0 1 1.06 1.06l-.707.708a2 2 0 0 0 0 2.828l.55.55a2 2 0 0 0 2.828 0l.708-.707a.75.75 0 0 1 1.06 1.06l-.707.708z"
      />
    </symbol>
    <symbol id="icon-send" viewBox="0 0 16 16" fill="currentColor">
      <path
        d="M15.854.146a.5.5 0 0 1 .058.638l-.058.07-9.5 9.5a.5.5 0 0 1-.233.131l-.095.015-4 1a.5.5 0 0 1-.607-.607l.02-.074 1-4a.5.5 0 0 1 .116-.217l.063-.06 9.5-9.5a.5.5 0 0 1 .765.638L12.207 5.5 7.5 10.207 5.793 8.5 13.646.646 15.146 2.146 14.5 2.793 15.854.146Z"
      />
    </symbol>
  </svg>
  <div id="app">
    <!-- Sidebar containing configuration and thread list -->
    <aside class="sidebar" aria-label="Settings panel" aria-hidden="true">
      <div class="sidebar-header">
        <h2>Settings</h2>
        <button type="button" id="closeSidebarBtn" class="sidebar-close" aria-label="Close settings">
          <svg class="icon" aria-hidden="true"><use href="#icon-close"></use></svg>
        </button>
      </div>
      <div class="form-group">
        <label for="endpointSelect">Quick-start endpoints</label>
        <select id="endpointSelect"></select>
      </div>
      <p id="endpointOnboardingHint" class="hint-text" role="note">
        Tip: Pick an API endpoint above to get started. Already configured this app on another device?
        <button type="button" id="importSettingsShortcut" class="link-btn">Import your settings file</button>
        instead.
      </p>
      <div class="form-group">
        <label for="endpointInput">API endpoint</label>
        <input type="text" id="endpointInput" placeholder="https://api.example.com/v1" />
      </div>
      <p id="endpointHint" class="hint-text" role="note"></p>
      <div class="form-group">
        <label for="modelSelect">Model</label>
        <div class="model-select-row">
          <button type="button" id="refreshModelsBtn">
            <svg class="icon" aria-hidden="true"><use href="#icon-refresh"></use></svg>
            <span class="btn-label">Refresh model list</span>
          </button>
          <select id="modelSelect"></select>
        </div>
      </div>
      <div class="form-group">
        <label for="tokenInput">API token</label>
        <div class="secret-field">
          <input
            type="text"
            id="tokenInput"
            name="api_token"
            class="secret-input masked"
            placeholder="sk-..."
            autocomplete="off"
            autocapitalize="off"
            autocorrect="off"
            spellcheck="false"
            inputmode="text"
            data-1p-ignore
            data-op-ignore
            data-lpignore="true"
            data-bwignore
            data-protonpass-ignore="true"
          />
          <button
            type="button"
            id="peekTokenBtn"
            class="icon-btn"
            aria-label="Show token"
            aria-pressed="false"
            title="Show token"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-eye"></use></svg>
            <span class="sr-only">Toggle token visibility</span>
          </button>
          <button
            type="button"
            id="copyTokenBtn"
            class="icon-btn"
            aria-label="Copy token"
            title="Copy token"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-copy"></use></svg>
            <span class="sr-only">Copy token to clipboard</span>
          </button>
        </div>
      </div>
      <hr />
      <div class="threads-header">
        <h3>Chats</h3>
      </div>
      <ul id="threadList" class="thread-list"></ul>
      <div class="actions" role="group" aria-label="Chat history and settings import and export">
        <div class="action-group">
          <span class="action-label">Chat history:</span>
          <button
            type="button"
            id="exportBtn"
            class="icon-btn"
            title="Export chat history"
            aria-label="Export chat history"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-export"></use></svg>
          </button>
          <button
            type="button"
            id="importBtn"
            class="icon-btn"
            title="Import chat history"
            aria-label="Import chat history"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-import"></use></svg>
          </button>
          <input type="file" id="importInput" accept="application/json" style="display: none;" />
        </div>
        <div class="action-group">
          <span class="action-label">Settings:</span>
          <button
            type="button"
            id="exportConfigBtn"
            class="icon-btn"
            title="Export settings"
            aria-label="Export settings"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-export"></use></svg>
          </button>
          <button
            type="button"
            id="importConfigBtn"
            class="icon-btn"
            title="Import settings"
            aria-label="Import settings"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-import"></use></svg>
          </button>
          <button
            type="button"
            id="shareConfigBtn"
            class="icon-btn"
            title="Share settings via QR code"
            aria-label="Share settings via QR code"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-qr"></use></svg>
          </button>
          <button
            type="button"
            id="copyConfigLinkBtn"
            class="icon-btn"
            title="Copy share link"
            aria-label="Copy share link"
          >
            <svg class="icon" aria-hidden="true"><use href="#icon-link"></use></svg>
          </button>
          <input type="file" id="importConfigInput" accept="application/json" style="display: none;" />
        </div>
      </div>
    </aside>
    <div id="sidebarOverlay" aria-hidden="true"></div>

    <!-- Main chat area -->
    <main class="chat-area">
      <div id="chatHeader" class="chat-header">
        <button type="button" id="openSidebarBtn" class="mobile-toggle" aria-label="Open settings">
          <svg class="icon" aria-hidden="true"><use href="#icon-menu"></use></svg>
        </button>
        <input type="text" id="threadTitleInput" class="thread-title" placeholder="Chat title" />
        <button
          type="button"
          id="aboutBtn"
          class="about-btn"
          aria-label="About &amp; Privacy"
          aria-haspopup="dialog"
          aria-expanded="false"
        >
          <svg class="icon" aria-hidden="true"><use href="#icon-info"></use></svg>
        </button>
      </div>
      <div id="promoBanner" class="promo-banner" role="region" aria-label="Journal Foundation notice" hidden>
        <span>
          Private local chat demo by
          <a href="https://JournalFoundation.org" target="_blank" rel="noopener">JournalFoundation.org</a>.
          Save this page to run it offline.
        </span>
        <button id="dismissPromoBtn" class="dismiss" aria-label="Dismiss notice">
          <svg class="icon" aria-hidden="true"><use href="#icon-close"></use></svg>
        </button>
      </div>
      <div id="chatNotice" class="chat-notice" role="status" aria-live="polite" hidden></div>
      <div
        id="authGuidance"
        class="chat-notice"
        role="status"
        aria-live="polite"
        aria-hidden="true"
        hidden
      >
        <p><strong>Trouble authenticating?</strong> Double-check your endpoint or import your saved settings file.</p>
        <div class="notice-actions" role="group" aria-label="Authentication help actions">
          <button type="button" id="authGuideEndpointBtn">Select API endpoint</button>
          <button type="button" id="authGuideImportBtn" class="secondary">Import settings</button>
        </div>
      </div>
      <div id="systemPromptContainer" class="system-prompt-container">
        <label for="systemPromptInput">System prompt:</label>
        <textarea id="systemPromptInput" placeholder="You are a helpful assistant."></textarea>
      </div>
      <div id="messages" class="messages"></div>
      <form id="messageForm" class="message-form">
        <div class="message-input-wrapper">
          <textarea id="messageInput" placeholder="Type your message" rows="3"></textarea>
          <div id="messageInputOverlay" class="message-input-overlay" aria-hidden="true"></div>
        </div>
        <button type="submit" id="sendBtn">
          <svg class="icon" aria-hidden="true"><use href="#icon-send"></use></svg>
          <span class="btn-label">Send</span>
        </button>
      </form>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite" aria-hidden="true" hidden></div>

  <div id="modalBackdrop" class="modal-backdrop" hidden></div>
  <div id="aboutModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="aboutTitle" hidden>
    <div class="sheet" role="document">
      <button type="button" class="modal-close" id="aboutCloseBtn" aria-label="Close">
        <svg class="icon" aria-hidden="true"><use href="#icon-close"></use></svg>
      </button>
      <h2 id="aboutTitle">Private &amp; Local — About this demo</h2>
      <p><strong>This is a single static HTML file.</strong> There is no backend, no database, and nothing on a server to capture your data. Your chats are stored in your browser.</p>

      <h3>How to run it anywhere</h3>
      <ul>
        <li><strong>Desktop:</strong> Right-click → <em>Save Page As…</em>, then open the saved file.</li>
        <li><strong>iPhone (Safari):</strong> Share → <em>Add to Home Screen</em>, or Share → <em>Save to Files</em>, then open it.</li>
      </ul>

      <h3>What’s stored locally</h3>
      <ul>
        <li><code>localStorage</code>: chat threads and messages.</li>
        <li><code>sessionStorage</code>: settings (endpoint, token, models) for the current session.</li>
      </ul>
      <p>No network calls happen unless you set an API endpoint and press <em>Send</em> (or <em>Refresh model list</em>).</p>

      <div class="cta-row">
        <a id="jfSiteLink" class="cta-link" href="https://JournalFoundation.org" target="_blank" rel="noopener">JournalFoundation.org</a>
        <a
          id="githubProjectLink"
          class="cta-link"
          href="https://github.com/JournalFoundation/privatelocalchat"
          target="_blank"
          rel="noopener"
        >
          <svg class="icon" aria-hidden="true"><use href="#icon-github"></use></svg>
          <span class="btn-label">Fork / contribute on GitHub</span>
        </a>
      </div>

      <div class="cta-row">
        <button id="downloadPageBtn" class="primary">
          <svg class="icon" aria-hidden="true"><use href="#icon-download"></use></svg>
          <span class="btn-label">Download this page</span>
        </button>
      </div>

      <p class="fine-print">
        Tip: You can also open this dialog directly with <code>?about=1</code> in the URL.
      </p>
    </div>
  </div>
  <div
    id="configQrModal"
    class="modal"
    role="dialog"
    aria-modal="true"
    aria-labelledby="configQrTitle"
    hidden
  >
    <div class="sheet" role="document">
      <button type="button" class="modal-close" id="configQrCloseBtn" aria-label="Close">
        <svg class="icon" aria-hidden="true"><use href="#icon-close"></use></svg>
      </button>
      <h2 id="configQrTitle">Share settings via QR code</h2>
      <p>Scan this QR code on another device to import these chat settings instantly.</p>
      <div class="qr-preview">
        <div
          id="configQrCode"
          class="qr-code"
          role="img"
          aria-label="QR code for shared chat settings"
        ></div>
        <div class="qr-link">
          <a id="configQrLink" href="#" target="_blank" rel="noopener">Link will appear after generating.</a>
        </div>
      </div>
    </div>
  </div>

  <script>
    /*
     * Private Chat Client: lightweight local chat UI for chat completion APIs.
     *
     * This implementation is based on PR #2 from the provided options.
     *
     * The script below manages chat threads, configuration, and interactions
     * with external API endpoints. It also enforces availability rules such
     * that a user cannot send a message until a thread is selected and the
     * endpoint and model are configured. Additionally, this version
     * supports pre-populating the chat title, system prompt, and message
     * fields via URL query parameters. See the parseUrlParams() function.
     */

    (() => {
      // DOM element references
      const endpointSelect = document.getElementById('endpointSelect');
      const endpointInput = document.getElementById('endpointInput');
      const tokenInput = document.getElementById('tokenInput');
      const modelSelect = document.getElementById('modelSelect');
      const refreshModelsBtn = document.getElementById('refreshModelsBtn');
      const endpointHint = document.getElementById('endpointHint');
      const threadList = document.getElementById('threadList');
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const importInput = document.getElementById('importInput');
      const exportConfigBtn = document.getElementById('exportConfigBtn');
      const importConfigBtn = document.getElementById('importConfigBtn');
      const importConfigInput = document.getElementById('importConfigInput');
      const importSettingsShortcut = document.getElementById('importSettingsShortcut');
      const openSidebarBtn = document.getElementById('openSidebarBtn');
      const closeSidebarBtn = document.getElementById('closeSidebarBtn');
      const sidebarOverlay = document.getElementById('sidebarOverlay');
      const sidebarEl = document.querySelector('.sidebar');
      const threadTitleInput = document.getElementById('threadTitleInput');
      const systemPromptInput = document.getElementById('systemPromptInput');
      const chatNotice = document.getElementById('chatNotice');
      const messagesEl = document.getElementById('messages');
      const messageForm = document.getElementById('messageForm');
      const messageInput = document.getElementById('messageInput');
      const messageInputOverlay = document.getElementById('messageInputOverlay');
      const sendBtn = document.getElementById('sendBtn');
      const authGuidance = document.getElementById('authGuidance');
      const authGuideEndpointBtn = document.getElementById('authGuideEndpointBtn');
      const authGuideImportBtn = document.getElementById('authGuideImportBtn');
      const aboutBtn = document.getElementById('aboutBtn');
      const promoBanner = document.getElementById('promoBanner');
      const dismissPromoBtn = document.getElementById('dismissPromoBtn');
      const aboutModal = document.getElementById('aboutModal');
      const modalBackdrop = document.getElementById('modalBackdrop');
      const toast = document.getElementById('toast');
      const aboutCloseBtn = document.getElementById('aboutCloseBtn');
      const downloadPageBtn = document.getElementById('downloadPageBtn');
      const peekTokenBtn = document.getElementById('peekTokenBtn');
      const copyTokenBtn = document.getElementById('copyTokenBtn');
      const shareConfigBtn = document.getElementById('shareConfigBtn');
      const configQrModal = document.getElementById('configQrModal');
      const configQrCloseBtn = document.getElementById('configQrCloseBtn');
      const configQrCode = document.getElementById('configQrCode');
      const configQrLink = document.getElementById('configQrLink');
      const copyConfigLinkBtn = document.getElementById('copyConfigLinkBtn');

      const createIcon = symbolId => {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'icon');
        svg.setAttribute('aria-hidden', 'true');
        const use = document.createElementNS('http://www.w3.org/2000/svg', 'use');
        use.setAttribute('href', `#${symbolId}`);
        svg.appendChild(use);
        return svg;
      };

      // Application state
      let config = {
        endpoint: '',
        token: '',
        model: ''
      };
      let threads = [];
      let currentThreadId = null;
      let models = [];
      let openThreadMenu = null;
      let toastHideTimer = null;
      let consecutiveAuthErrors = 0;
      const desktopMediaQuery = window.matchMedia('(min-width: 900px)');

      let activeModal = null;
      let activeModalTrigger = null;
      let configQrInstance = null;
      let latestConfigShareUrl = '';
      let qrLibraryLoaded = false;

      const qrLibBase64 = `
dmFyIFFSQ29kZTshZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe3RoaXMubW9kZT1jLk1PREVfOEJJ
VF9CWVRFLHRoaXMuZGF0YT1hLHRoaXMucGFyc2VkRGF0YT1bXTtmb3IodmFyIGI9W10sZD0wLGU9
dGhpcy5kYXRhLmxlbmd0aDtlPmQ7ZCsrKXt2YXIgZj10aGlzLmRhdGEuY2hhckNvZGVBdChkKTtm
PjY1NTM2PyhiWzBdPTI0MHwoMTgzNTAwOCZmKT4+PjE4LGJbMV09MTI4fCgyNTgwNDgmZik+Pj4x
MixiWzJdPTEyOHwoNDAzMiZmKT4+PjYsYlszXT0xMjh8NjMmZik6Zj4yMDQ4PyhiWzBdPTIyNHwo
NjE0NDAmZik+Pj4xMixiWzFdPTEyOHwoNDAzMiZmKT4+PjYsYlsyXT0xMjh8NjMmZik6Zj4xMjg/
KGJbMF09MTkyfCgxOTg0JmYpPj4+NixiWzFdPTEyOHw2MyZmKTpiWzBdPWYsdGhpcy5wYXJzZWRE
YXRhPXRoaXMucGFyc2VkRGF0YS5jb25jYXQoYil9dGhpcy5wYXJzZWREYXRhLmxlbmd0aCE9dGhp
cy5kYXRhLmxlbmd0aCYmKHRoaXMucGFyc2VkRGF0YS51bnNoaWZ0KDE5MSksdGhpcy5wYXJzZWRE
YXRhLnVuc2hpZnQoMTg3KSx0aGlzLnBhcnNlZERhdGEudW5zaGlmdCgyMzkpKX1mdW5jdGlvbiBi
KGEsYil7dGhpcy50eXBlTnVtYmVyPWEsdGhpcy5lcnJvckNvcnJlY3RMZXZlbD1iLHRoaXMubW9k
dWxlcz1udWxsLHRoaXMubW9kdWxlQ291bnQ9MCx0aGlzLmRhdGFDYWNoZT1udWxsLHRoaXMuZGF0
YUxpc3Q9W119ZnVuY3Rpb24gaShhLGIpe2lmKHZvaWQgMD09YS5sZW5ndGgpdGhyb3cgbmV3IEVy
cm9yKGEubGVuZ3RoKyIvIitiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoJiYwPT1hW2NdOyljKys7
dGhpcy5udW09bmV3IEFycmF5KGEubGVuZ3RoLWMrYik7Zm9yKHZhciBkPTA7ZDxhLmxlbmd0aC1j
O2QrKyl0aGlzLm51bVtkXT1hW2QrY119ZnVuY3Rpb24gaihhLGIpe3RoaXMudG90YWxDb3VudD1h
LHRoaXMuZGF0YUNvdW50PWJ9ZnVuY3Rpb24gaygpe3RoaXMuYnVmZmVyPVtdLHRoaXMubGVuZ3Ro
PTB9ZnVuY3Rpb24gbSgpe3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgQ2FudmFzUmVuZGVyaW5n
Q29udGV4dDJEfWZ1bmN0aW9uIG4oKXt2YXIgYT0hMSxiPW5hdmlnYXRvci51c2VyQWdlbnQ7cmV0
dXJuL2FuZHJvaWQvaS50ZXN0KGIpJiYoYT0hMCxhTWF0PWIudG9TdHJpbmcoKS5tYXRjaCgvYW5k
cm9pZCAoWzAtOV1cLlswLTldKS9pKSxhTWF0JiZhTWF0WzFdJiYoYT1wYXJzZUZsb2F0KGFNYXRb
MV0pKSksYX1mdW5jdGlvbiByKGEsYil7Zm9yKHZhciBjPTEsZT1zKGEpLGY9MCxnPWwubGVuZ3Ro
O2c+PWY7ZisrKXt2YXIgaD0wO3N3aXRjaChiKXtjYXNlIGQuTDpoPWxbZl1bMF07YnJlYWs7Y2Fz
ZSBkLk06aD1sW2ZdWzFdO2JyZWFrO2Nhc2UgZC5ROmg9bFtmXVsyXTticmVhaztjYXNlIGQuSDpo
PWxbZl1bM119aWYoaD49ZSlicmVhaztjKyt9aWYoYz5sLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3Io
IlRvbyBsb25nIGRhdGEiKTtyZXR1cm4gY31mdW5jdGlvbiBzKGEpe3ZhciBiPWVuY29kZVVSSShh
KS50b1N0cmluZygpLnJlcGxhY2UoL1wlWzAtOWEtZkEtRl17Mn0vZywiYSIpO3JldHVybiBiLmxl
bmd0aCsoYi5sZW5ndGghPWE/MzowKX1hLnByb3RvdHlwZT17Z2V0TGVuZ3RoOmZ1bmN0aW9uKCl7
cmV0dXJuIHRoaXMucGFyc2VkRGF0YS5sZW5ndGh9LHdyaXRlOmZ1bmN0aW9uKGEpe2Zvcih2YXIg
Yj0wLGM9dGhpcy5wYXJzZWREYXRhLmxlbmd0aDtjPmI7YisrKWEucHV0KHRoaXMucGFyc2VkRGF0
YVtiXSw4KX19LGIucHJvdG90eXBlPXthZGREYXRhOmZ1bmN0aW9uKGIpe3ZhciBjPW5ldyBhKGIp
O3RoaXMuZGF0YUxpc3QucHVzaChjKSx0aGlzLmRhdGFDYWNoZT1udWxsfSxpc0Rhcms6ZnVuY3Rp
b24oYSxiKXtpZigwPmF8fHRoaXMubW9kdWxlQ291bnQ8PWF8fDA+Ynx8dGhpcy5tb2R1bGVDb3Vu
dDw9Yil0aHJvdyBuZXcgRXJyb3IoYSsiLCIrYik7cmV0dXJuIHRoaXMubW9kdWxlc1thXVtiXX0s
Z2V0TW9kdWxlQ291bnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tb2R1bGVDb3VudH0sbWFrZTpm
dW5jdGlvbigpe3RoaXMubWFrZUltcGwoITEsdGhpcy5nZXRCZXN0TWFza1BhdHRlcm4oKSl9LG1h
a2VJbXBsOmZ1bmN0aW9uKGEsYyl7dGhpcy5tb2R1bGVDb3VudD00KnRoaXMudHlwZU51bWJlcisx
Nyx0aGlzLm1vZHVsZXM9bmV3IEFycmF5KHRoaXMubW9kdWxlQ291bnQpO2Zvcih2YXIgZD0wO2Q8
dGhpcy5tb2R1bGVDb3VudDtkKyspe3RoaXMubW9kdWxlc1tkXT1uZXcgQXJyYXkodGhpcy5tb2R1
bGVDb3VudCk7Zm9yKHZhciBlPTA7ZTx0aGlzLm1vZHVsZUNvdW50O2UrKyl0aGlzLm1vZHVsZXNb
ZF1bZV09bnVsbH10aGlzLnNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwwKSx0aGlzLnNldHVw
UG9zaXRpb25Qcm9iZVBhdHRlcm4odGhpcy5tb2R1bGVDb3VudC03LDApLHRoaXMuc2V0dXBQb3Np
dGlvblByb2JlUGF0dGVybigwLHRoaXMubW9kdWxlQ291bnQtNyksdGhpcy5zZXR1cFBvc2l0aW9u
QWRqdXN0UGF0dGVybigpLHRoaXMuc2V0dXBUaW1pbmdQYXR0ZXJuKCksdGhpcy5zZXR1cFR5cGVJ
bmZvKGEsYyksdGhpcy50eXBlTnVtYmVyPj03JiZ0aGlzLnNldHVwVHlwZU51bWJlcihhKSxudWxs
PT10aGlzLmRhdGFDYWNoZSYmKHRoaXMuZGF0YUNhY2hlPWIuY3JlYXRlRGF0YSh0aGlzLnR5cGVO
dW1iZXIsdGhpcy5lcnJvckNvcnJlY3RMZXZlbCx0aGlzLmRhdGFMaXN0KSksdGhpcy5tYXBEYXRh
KHRoaXMuZGF0YUNhY2hlLGMpfSxzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuOmZ1bmN0aW9uKGEs
Yil7Zm9yKHZhciBjPS0xOzc+PWM7YysrKWlmKCEoLTE+PWErY3x8dGhpcy5tb2R1bGVDb3VudDw9
YStjKSlmb3IodmFyIGQ9LTE7Nz49ZDtkKyspLTE+PWIrZHx8dGhpcy5tb2R1bGVDb3VudDw9Yitk
fHwodGhpcy5tb2R1bGVzW2ErY11bYitkXT1jPj0wJiY2Pj1jJiYoMD09ZHx8Nj09ZCl8fGQ+PTAm
JjY+PWQmJigwPT1jfHw2PT1jKXx8Yz49MiYmND49YyYmZD49MiYmND49ZD8hMDohMSl9LGdldEJl
c3RNYXNrUGF0dGVybjpmdW5jdGlvbigpe2Zvcih2YXIgYT0wLGI9MCxjPTA7OD5jO2MrKyl7dGhp
cy5tYWtlSW1wbCghMCxjKTt2YXIgZD1mLmdldExvc3RQb2ludCh0aGlzKTsoMD09Y3x8YT5kKSYm
KGE9ZCxiPWMpfXJldHVybiBifSxjcmVhdGVNb3ZpZUNsaXA6ZnVuY3Rpb24oYSxiLGMpe3ZhciBk
PWEuY3JlYXRlRW1wdHlNb3ZpZUNsaXAoYixjKSxlPTE7dGhpcy5tYWtlKCk7Zm9yKHZhciBmPTA7
Zjx0aGlzLm1vZHVsZXMubGVuZ3RoO2YrKylmb3IodmFyIGc9ZiplLGg9MDtoPHRoaXMubW9kdWxl
c1tmXS5sZW5ndGg7aCsrKXt2YXIgaT1oKmUsaj10aGlzLm1vZHVsZXNbZl1baF07aiYmKGQuYmVn
aW5GaWxsKDAsMTAwKSxkLm1vdmVUbyhpLGcpLGQubGluZVRvKGkrZSxnKSxkLmxpbmVUbyhpK2Us
ZytlKSxkLmxpbmVUbyhpLGcrZSksZC5lbmRGaWxsKCkpfXJldHVybiBkfSxzZXR1cFRpbWluZ1Bh
dHRlcm46ZnVuY3Rpb24oKXtmb3IodmFyIGE9ODthPHRoaXMubW9kdWxlQ291bnQtODthKyspbnVs
bD09dGhpcy5tb2R1bGVzW2FdWzZdJiYodGhpcy5tb2R1bGVzW2FdWzZdPTA9PWElMik7Zm9yKHZh
ciBiPTg7Yjx0aGlzLm1vZHVsZUNvdW50LTg7YisrKW51bGw9PXRoaXMubW9kdWxlc1s2XVtiXSYm
KHRoaXMubW9kdWxlc1s2XVtiXT0wPT1iJTIpfSxzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybjpm
dW5jdGlvbigpe2Zvcih2YXIgYT1mLmdldFBhdHRlcm5Qb3NpdGlvbih0aGlzLnR5cGVOdW1iZXIp
LGI9MDtiPGEubGVuZ3RoO2IrKylmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9YVti
XSxlPWFbY107aWYobnVsbD09dGhpcy5tb2R1bGVzW2RdW2VdKWZvcih2YXIgZz0tMjsyPj1nO2cr
Kylmb3IodmFyIGg9LTI7Mj49aDtoKyspdGhpcy5tb2R1bGVzW2QrZ11bZStoXT0tMj09Z3x8Mj09
Z3x8LTI9PWh8fDI9PWh8fDA9PWcmJjA9PWg/ITA6ITF9fSxzZXR1cFR5cGVOdW1iZXI6ZnVuY3Rp
b24oYSl7Zm9yKHZhciBiPWYuZ2V0QkNIVHlwZU51bWJlcih0aGlzLnR5cGVOdW1iZXIpLGM9MDsx
OD5jO2MrKyl7dmFyIGQ9IWEmJjE9PSgxJmI+PmMpO3RoaXMubW9kdWxlc1tNYXRoLmZsb29yKGMv
MyldW2MlMyt0aGlzLm1vZHVsZUNvdW50LTgtM109ZH1mb3IodmFyIGM9MDsxOD5jO2MrKyl7dmFy
IGQ9IWEmJjE9PSgxJmI+PmMpO3RoaXMubW9kdWxlc1tjJTMrdGhpcy5tb2R1bGVDb3VudC04LTNd
W01hdGguZmxvb3IoYy8zKV09ZH19LHNldHVwVHlwZUluZm86ZnVuY3Rpb24oYSxiKXtmb3IodmFy
IGM9dGhpcy5lcnJvckNvcnJlY3RMZXZlbDw8M3xiLGQ9Zi5nZXRCQ0hUeXBlSW5mbyhjKSxlPTA7
MTU+ZTtlKyspe3ZhciBnPSFhJiYxPT0oMSZkPj5lKTs2PmU/dGhpcy5tb2R1bGVzW2VdWzhdPWc6
OD5lP3RoaXMubW9kdWxlc1tlKzFdWzhdPWc6dGhpcy5tb2R1bGVzW3RoaXMubW9kdWxlQ291bnQt
MTUrZV1bOF09Z31mb3IodmFyIGU9MDsxNT5lO2UrKyl7dmFyIGc9IWEmJjE9PSgxJmQ+PmUpOzg+
ZT90aGlzLm1vZHVsZXNbOF1bdGhpcy5tb2R1bGVDb3VudC1lLTFdPWc6OT5lP3RoaXMubW9kdWxl
c1s4XVsxNS1lLTErMV09Zzp0aGlzLm1vZHVsZXNbOF1bMTUtZS0xXT1nfXRoaXMubW9kdWxlc1t0
aGlzLm1vZHVsZUNvdW50LThdWzhdPSFhfSxtYXBEYXRhOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBj
PS0xLGQ9dGhpcy5tb2R1bGVDb3VudC0xLGU9NyxnPTAsaD10aGlzLm1vZHVsZUNvdW50LTE7aD4w
O2gtPTIpZm9yKDY9PWgmJmgtLTs7KXtmb3IodmFyIGk9MDsyPmk7aSsrKWlmKG51bGw9PXRoaXMu
bW9kdWxlc1tkXVtoLWldKXt2YXIgaj0hMTtnPGEubGVuZ3RoJiYoaj0xPT0oMSZhW2ddPj4+ZSkp
O3ZhciBrPWYuZ2V0TWFzayhiLGQsaC1pKTtrJiYoaj0haiksdGhpcy5tb2R1bGVzW2RdW2gtaV09
aixlLS0sLTE9PWUmJihnKyssZT03KX1pZihkKz1jLDA+ZHx8dGhpcy5tb2R1bGVDb3VudDw9ZCl7
ZC09YyxjPS1jO2JyZWFrfX19fSxiLlBBRDA9MjM2LGIuUEFEMT0xNyxiLmNyZWF0ZURhdGE9ZnVu
Y3Rpb24oYSxjLGQpe2Zvcih2YXIgZT1qLmdldFJTQmxvY2tzKGEsYyksZz1uZXcgayxoPTA7aDxk
Lmxlbmd0aDtoKyspe3ZhciBpPWRbaF07Zy5wdXQoaS5tb2RlLDQpLGcucHV0KGkuZ2V0TGVuZ3Ro
KCksZi5nZXRMZW5ndGhJbkJpdHMoaS5tb2RlLGEpKSxpLndyaXRlKGcpfWZvcih2YXIgbD0wLGg9
MDtoPGUubGVuZ3RoO2grKylsKz1lW2hdLmRhdGFDb3VudDtpZihnLmdldExlbmd0aEluQml0cygp
PjgqbCl0aHJvdyBuZXcgRXJyb3IoImNvZGUgbGVuZ3RoIG92ZXJmbG93LiAoIitnLmdldExlbmd0
aEluQml0cygpKyI+Iis4KmwrIikiKTtmb3IoZy5nZXRMZW5ndGhJbkJpdHMoKSs0PD04KmwmJmcu
cHV0KDAsNCk7MCE9Zy5nZXRMZW5ndGhJbkJpdHMoKSU4OylnLnB1dEJpdCghMSk7Zm9yKDs7KXtp
ZihnLmdldExlbmd0aEluQml0cygpPj04KmwpYnJlYWs7aWYoZy5wdXQoYi5QQUQwLDgpLGcuZ2V0
TGVuZ3RoSW5CaXRzKCk+PTgqbClicmVhaztnLnB1dChiLlBBRDEsOCl9cmV0dXJuIGIuY3JlYXRl
Qnl0ZXMoZyxlKX0sYi5jcmVhdGVCeXRlcz1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9MCxl
PTAsZz1uZXcgQXJyYXkoYi5sZW5ndGgpLGg9bmV3IEFycmF5KGIubGVuZ3RoKSxqPTA7ajxiLmxl
bmd0aDtqKyspe3ZhciBrPWJbal0uZGF0YUNvdW50LGw9YltqXS50b3RhbENvdW50LWs7ZD1NYXRo
Lm1heChkLGspLGU9TWF0aC5tYXgoZSxsKSxnW2pdPW5ldyBBcnJheShrKTtmb3IodmFyIG09MDtt
PGdbal0ubGVuZ3RoO20rKylnW2pdW21dPTI1NSZhLmJ1ZmZlclttK2NdO2MrPWs7dmFyIG49Zi5n
ZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsKGwpLG89bmV3IGkoZ1tqXSxuLmdldExlbmd0aCgpLTEp
LHA9by5tb2Qobik7aFtqXT1uZXcgQXJyYXkobi5nZXRMZW5ndGgoKS0xKTtmb3IodmFyIG09MDtt
PGhbal0ubGVuZ3RoO20rKyl7dmFyIHE9bStwLmdldExlbmd0aCgpLWhbal0ubGVuZ3RoO2hbal1b
bV09cT49MD9wLmdldChxKTowfX1mb3IodmFyIHI9MCxtPTA7bTxiLmxlbmd0aDttKyspcis9Yltt
XS50b3RhbENvdW50O2Zvcih2YXIgcz1uZXcgQXJyYXkociksdD0wLG09MDtkPm07bSsrKWZvcih2
YXIgaj0wO2o8Yi5sZW5ndGg7aisrKW08Z1tqXS5sZW5ndGgmJihzW3QrK109Z1tqXVttXSk7Zm9y
KHZhciBtPTA7ZT5tO20rKylmb3IodmFyIGo9MDtqPGIubGVuZ3RoO2orKyltPGhbal0ubGVuZ3Ro
JiYoc1t0KytdPWhbal1bbV0pO3JldHVybiBzfTtmb3IodmFyIGM9e01PREVfTlVNQkVSOjEsTU9E
RV9BTFBIQV9OVU06MixNT0RFXzhCSVRfQllURTo0LE1PREVfS0FOSkk6OH0sZD17TDoxLE06MCxR
OjMsSDoyfSxlPXtQQVRURVJOMDAwOjAsUEFUVEVSTjAwMToxLFBBVFRFUk4wMTA6MixQQVRURVJO
MDExOjMsUEFUVEVSTjEwMDo0LFBBVFRFUk4xMDE6NSxQQVRURVJOMTEwOjYsUEFUVEVSTjExMTo3
fSxmPXtQQVRURVJOX1BPU0lUSU9OX1RBQkxFOltbXSxbNiwxOF0sWzYsMjJdLFs2LDI2XSxbNiwz
MF0sWzYsMzRdLFs2LDIyLDM4XSxbNiwyNCw0Ml0sWzYsMjYsNDZdLFs2LDI4LDUwXSxbNiwzMCw1
NF0sWzYsMzIsNThdLFs2LDM0LDYyXSxbNiwyNiw0Niw2Nl0sWzYsMjYsNDgsNzBdLFs2LDI2LDUw
LDc0XSxbNiwzMCw1NCw3OF0sWzYsMzAsNTYsODJdLFs2LDMwLDU4LDg2XSxbNiwzNCw2Miw5MF0s
WzYsMjgsNTAsNzIsOTRdLFs2LDI2LDUwLDc0LDk4XSxbNiwzMCw1NCw3OCwxMDJdLFs2LDI4LDU0
LDgwLDEwNl0sWzYsMzIsNTgsODQsMTEwXSxbNiwzMCw1OCw4NiwxMTRdLFs2LDM0LDYyLDkwLDEx
OF0sWzYsMjYsNTAsNzQsOTgsMTIyXSxbNiwzMCw1NCw3OCwxMDIsMTI2XSxbNiwyNiw1Miw3OCwx
MDQsMTMwXSxbNiwzMCw1Niw4MiwxMDgsMTM0XSxbNiwzNCw2MCw4NiwxMTIsMTM4XSxbNiwzMCw1
OCw4NiwxMTQsMTQyXSxbNiwzNCw2Miw5MCwxMTgsMTQ2XSxbNiwzMCw1NCw3OCwxMDIsMTI2LDE1
MF0sWzYsMjQsNTAsNzYsMTAyLDEyOCwxNTRdLFs2LDI4LDU0LDgwLDEwNiwxMzIsMTU4XSxbNiwz
Miw1OCw4NCwxMTAsMTM2LDE2Ml0sWzYsMjYsNTQsODIsMTEwLDEzOCwxNjZdLFs2LDMwLDU4LDg2
LDExNCwxNDIsMTcwXV0sRzE1OjEzMzUsRzE4Ojc5NzMsRzE1X01BU0s6MjE1MjIsZ2V0QkNIVHlw
ZUluZm86ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPWE8PDEwO2YuZ2V0QkNIRGlnaXQoYiktZi5nZXRC
Q0hEaWdpdChmLkcxNSk+PTA7KWJePWYuRzE1PDxmLmdldEJDSERpZ2l0KGIpLWYuZ2V0QkNIRGln
aXQoZi5HMTUpO3JldHVybihhPDwxMHxiKV5mLkcxNV9NQVNLfSxnZXRCQ0hUeXBlTnVtYmVyOmZ1
bmN0aW9uKGEpe2Zvcih2YXIgYj1hPDwxMjtmLmdldEJDSERpZ2l0KGIpLWYuZ2V0QkNIRGlnaXQo
Zi5HMTgpPj0wOyliXj1mLkcxODw8Zi5nZXRCQ0hEaWdpdChiKS1mLmdldEJDSERpZ2l0KGYuRzE4
KTtyZXR1cm4gYTw8MTJ8Yn0sZ2V0QkNIRGlnaXQ6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTA7MCE9
YTspYisrLGE+Pj49MTtyZXR1cm4gYn0sZ2V0UGF0dGVyblBvc2l0aW9uOmZ1bmN0aW9uKGEpe3Jl
dHVybiBmLlBBVFRFUk5fUE9TSVRJT05fVEFCTEVbYS0xXX0sZ2V0TWFzazpmdW5jdGlvbihhLGIs
Yyl7c3dpdGNoKGEpe2Nhc2UgZS5QQVRURVJOMDAwOnJldHVybiAwPT0oYitjKSUyO2Nhc2UgZS5Q
QVRURVJOMDAxOnJldHVybiAwPT1iJTI7Y2FzZSBlLlBBVFRFUk4wMTA6cmV0dXJuIDA9PWMlMztj
YXNlIGUuUEFUVEVSTjAxMTpyZXR1cm4gMD09KGIrYyklMztjYXNlIGUuUEFUVEVSTjEwMDpyZXR1
cm4gMD09KE1hdGguZmxvb3IoYi8yKStNYXRoLmZsb29yKGMvMykpJTI7Y2FzZSBlLlBBVFRFUk4x
MDE6cmV0dXJuIDA9PWIqYyUyK2IqYyUzO2Nhc2UgZS5QQVRURVJOMTEwOnJldHVybiAwPT0oYipj
JTIrYipjJTMpJTI7Y2FzZSBlLlBBVFRFUk4xMTE6cmV0dXJuIDA9PShiKmMlMysoYitjKSUyKSUy
O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJiYWQgbWFza1BhdHRlcm46IithKX19LGdldEVycm9y
Q29ycmVjdFBvbHlub21pYWw6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW5ldyBpKFsxXSwwKSxjPTA7
YT5jO2MrKyliPWIubXVsdGlwbHkobmV3IGkoWzEsZy5nZXhwKGMpXSwwKSk7cmV0dXJuIGJ9LGdl
dExlbmd0aEluQml0czpmdW5jdGlvbihhLGIpe2lmKGI+PTEmJjEwPmIpc3dpdGNoKGEpe2Nhc2Ug
Yy5NT0RFX05VTUJFUjpyZXR1cm4gMTA7Y2FzZSBjLk1PREVfQUxQSEFfTlVNOnJldHVybiA5O2Nh
c2UgYy5NT0RFXzhCSVRfQllURTpyZXR1cm4gODtjYXNlIGMuTU9ERV9LQU5KSTpyZXR1cm4gODtk
ZWZhdWx0OnRocm93IG5ldyBFcnJvcigibW9kZToiK2EpfWVsc2UgaWYoMjc+Yilzd2l0Y2goYSl7
Y2FzZSBjLk1PREVfTlVNQkVSOnJldHVybiAxMjtjYXNlIGMuTU9ERV9BTFBIQV9OVU06cmV0dXJu
IDExO2Nhc2UgYy5NT0RFXzhCSVRfQllURTpyZXR1cm4gMTY7Y2FzZSBjLk1PREVfS0FOSkk6cmV0
dXJuIDEwO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJtb2RlOiIrYSl9ZWxzZXtpZighKDQxPmIp
KXRocm93IG5ldyBFcnJvcigidHlwZToiK2IpO3N3aXRjaChhKXtjYXNlIGMuTU9ERV9OVU1CRVI6
cmV0dXJuIDE0O2Nhc2UgYy5NT0RFX0FMUEhBX05VTTpyZXR1cm4gMTM7Y2FzZSBjLk1PREVfOEJJ
VF9CWVRFOnJldHVybiAxNjtjYXNlIGMuTU9ERV9LQU5KSTpyZXR1cm4gMTI7ZGVmYXVsdDp0aHJv
dyBuZXcgRXJyb3IoIm1vZGU6IithKX19fSxnZXRMb3N0UG9pbnQ6ZnVuY3Rpb24oYSl7Zm9yKHZh
ciBiPWEuZ2V0TW9kdWxlQ291bnQoKSxjPTAsZD0wO2I+ZDtkKyspZm9yKHZhciBlPTA7Yj5lO2Ur
Kyl7Zm9yKHZhciBmPTAsZz1hLmlzRGFyayhkLGUpLGg9LTE7MT49aDtoKyspaWYoISgwPmQraHx8
ZCtoPj1iKSlmb3IodmFyIGk9LTE7MT49aTtpKyspMD5lK2l8fGUraT49Ynx8KDAhPWh8fDAhPWkp
JiZnPT1hLmlzRGFyayhkK2gsZStpKSYmZisrO2Y+NSYmKGMrPTMrZi01KX1mb3IodmFyIGQ9MDti
LTE+ZDtkKyspZm9yKHZhciBlPTA7Yi0xPmU7ZSsrKXt2YXIgaj0wO2EuaXNEYXJrKGQsZSkmJmor
KyxhLmlzRGFyayhkKzEsZSkmJmorKyxhLmlzRGFyayhkLGUrMSkmJmorKyxhLmlzRGFyayhkKzEs
ZSsxKSYmaisrLCgwPT1qfHw0PT1qKSYmKGMrPTMpfWZvcih2YXIgZD0wO2I+ZDtkKyspZm9yKHZh
ciBlPTA7Yi02PmU7ZSsrKWEuaXNEYXJrKGQsZSkmJiFhLmlzRGFyayhkLGUrMSkmJmEuaXNEYXJr
KGQsZSsyKSYmYS5pc0RhcmsoZCxlKzMpJiZhLmlzRGFyayhkLGUrNCkmJiFhLmlzRGFyayhkLGUr
NSkmJmEuaXNEYXJrKGQsZSs2KSYmKGMrPTQwKTtmb3IodmFyIGU9MDtiPmU7ZSsrKWZvcih2YXIg
ZD0wO2ItNj5kO2QrKylhLmlzRGFyayhkLGUpJiYhYS5pc0RhcmsoZCsxLGUpJiZhLmlzRGFyayhk
KzIsZSkmJmEuaXNEYXJrKGQrMyxlKSYmYS5pc0RhcmsoZCs0LGUpJiYhYS5pc0RhcmsoZCs1LGUp
JiZhLmlzRGFyayhkKzYsZSkmJihjKz00MCk7Zm9yKHZhciBrPTAsZT0wO2I+ZTtlKyspZm9yKHZh
ciBkPTA7Yj5kO2QrKylhLmlzRGFyayhkLGUpJiZrKys7dmFyIGw9TWF0aC5hYnMoMTAwKmsvYi9i
LTUwKS81O3JldHVybiBjKz0xMCpsfX0sZz17Z2xvZzpmdW5jdGlvbihhKXtpZigxPmEpdGhyb3cg
bmV3IEVycm9yKCJnbG9nKCIrYSsiKSIpO3JldHVybiBnLkxPR19UQUJMRVthXX0sZ2V4cDpmdW5j
dGlvbihhKXtmb3IoOzA+YTspYSs9MjU1O2Zvcig7YT49MjU2OylhLT0yNTU7cmV0dXJuIGcuRVhQ
X1RBQkxFW2FdfSxFWFBfVEFCTEU6bmV3IEFycmF5KDI1NiksTE9HX1RBQkxFOm5ldyBBcnJheSgy
NTYpfSxoPTA7OD5oO2grKylnLkVYUF9UQUJMRVtoXT0xPDxoO2Zvcih2YXIgaD04OzI1Nj5oO2gr
KylnLkVYUF9UQUJMRVtoXT1nLkVYUF9UQUJMRVtoLTRdXmcuRVhQX1RBQkxFW2gtNV1eZy5FWFBf
VEFCTEVbaC02XV5nLkVYUF9UQUJMRVtoLThdO2Zvcih2YXIgaD0wOzI1NT5oO2grKylnLkxPR19U
QUJMRVtnLkVYUF9UQUJMRVtoXV09aDtpLnByb3RvdHlwZT17Z2V0OmZ1bmN0aW9uKGEpe3JldHVy
biB0aGlzLm51bVthXX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnVtLmxlbmd0
aH0sbXVsdGlwbHk6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPW5ldyBBcnJheSh0aGlzLmdldExlbmd0
aCgpK2EuZ2V0TGVuZ3RoKCktMSksYz0wO2M8dGhpcy5nZXRMZW5ndGgoKTtjKyspZm9yKHZhciBk
PTA7ZDxhLmdldExlbmd0aCgpO2QrKyliW2MrZF1ePWcuZ2V4cChnLmdsb2codGhpcy5nZXQoYykp
K2cuZ2xvZyhhLmdldChkKSkpO3JldHVybiBuZXcgaShiLDApfSxtb2Q6ZnVuY3Rpb24oYSl7aWYo
dGhpcy5nZXRMZW5ndGgoKS1hLmdldExlbmd0aCgpPDApcmV0dXJuIHRoaXM7Zm9yKHZhciBiPWcu
Z2xvZyh0aGlzLmdldCgwKSktZy5nbG9nKGEuZ2V0KDApKSxjPW5ldyBBcnJheSh0aGlzLmdldExl
bmd0aCgpKSxkPTA7ZDx0aGlzLmdldExlbmd0aCgpO2QrKyljW2RdPXRoaXMuZ2V0KGQpO2Zvcih2
YXIgZD0wO2Q8YS5nZXRMZW5ndGgoKTtkKyspY1tkXV49Zy5nZXhwKGcuZ2xvZyhhLmdldChkKSkr
Yik7cmV0dXJuIG5ldyBpKGMsMCkubW9kKGEpfX0sai5SU19CTE9DS19UQUJMRT1bWzEsMjYsMTld
LFsxLDI2LDE2XSxbMSwyNiwxM10sWzEsMjYsOV0sWzEsNDQsMzRdLFsxLDQ0LDI4XSxbMSw0NCwy
Ml0sWzEsNDQsMTZdLFsxLDcwLDU1XSxbMSw3MCw0NF0sWzIsMzUsMTddLFsyLDM1LDEzXSxbMSwx
MDAsODBdLFsyLDUwLDMyXSxbMiw1MCwyNF0sWzQsMjUsOV0sWzEsMTM0LDEwOF0sWzIsNjcsNDNd
LFsyLDMzLDE1LDIsMzQsMTZdLFsyLDMzLDExLDIsMzQsMTJdLFsyLDg2LDY4XSxbNCw0MywyN10s
WzQsNDMsMTldLFs0LDQzLDE1XSxbMiw5OCw3OF0sWzQsNDksMzFdLFsyLDMyLDE0LDQsMzMsMTVd
LFs0LDM5LDEzLDEsNDAsMTRdLFsyLDEyMSw5N10sWzIsNjAsMzgsMiw2MSwzOV0sWzQsNDAsMTgs
Miw0MSwxOV0sWzQsNDAsMTQsMiw0MSwxNV0sWzIsMTQ2LDExNl0sWzMsNTgsMzYsMiw1OSwzN10s
WzQsMzYsMTYsNCwzNywxN10sWzQsMzYsMTIsNCwzNywxM10sWzIsODYsNjgsMiw4Nyw2OV0sWzQs
NjksNDMsMSw3MCw0NF0sWzYsNDMsMTksMiw0NCwyMF0sWzYsNDMsMTUsMiw0NCwxNl0sWzQsMTAx
LDgxXSxbMSw4MCw1MCw0LDgxLDUxXSxbNCw1MCwyMiw0LDUxLDIzXSxbMywzNiwxMiw4LDM3LDEz
XSxbMiwxMTYsOTIsMiwxMTcsOTNdLFs2LDU4LDM2LDIsNTksMzddLFs0LDQ2LDIwLDYsNDcsMjFd
LFs3LDQyLDE0LDQsNDMsMTVdLFs0LDEzMywxMDddLFs4LDU5LDM3LDEsNjAsMzhdLFs4LDQ0LDIw
LDQsNDUsMjFdLFsxMiwzMywxMSw0LDM0LDEyXSxbMywxNDUsMTE1LDEsMTQ2LDExNl0sWzQsNjQs
NDAsNSw2NSw0MV0sWzExLDM2LDE2LDUsMzcsMTddLFsxMSwzNiwxMiw1LDM3LDEzXSxbNSwxMDks
ODcsMSwxMTAsODhdLFs1LDY1LDQxLDUsNjYsNDJdLFs1LDU0LDI0LDcsNTUsMjVdLFsxMSwzNiwx
Ml0sWzUsMTIyLDk4LDEsMTIzLDk5XSxbNyw3Myw0NSwzLDc0LDQ2XSxbMTUsNDMsMTksMiw0NCwy
MF0sWzMsNDUsMTUsMTMsNDYsMTZdLFsxLDEzNSwxMDcsNSwxMzYsMTA4XSxbMTAsNzQsNDYsMSw3
NSw0N10sWzEsNTAsMjIsMTUsNTEsMjNdLFsyLDQyLDE0LDE3LDQzLDE1XSxbNSwxNTAsMTIwLDEs
MTUxLDEyMV0sWzksNjksNDMsNCw3MCw0NF0sWzE3LDUwLDIyLDEsNTEsMjNdLFsyLDQyLDE0LDE5
LDQzLDE1XSxbMywxNDEsMTEzLDQsMTQyLDExNF0sWzMsNzAsNDQsMTEsNzEsNDVdLFsxNyw0Nywy
MSw0LDQ4LDIyXSxbOSwzOSwxMywxNiw0MCwxNF0sWzMsMTM1LDEwNyw1LDEzNiwxMDhdLFszLDY3
LDQxLDEzLDY4LDQyXSxbMTUsNTQsMjQsNSw1NSwyNV0sWzE1LDQzLDE1LDEwLDQ0LDE2XSxbNCwx
NDQsMTE2LDQsMTQ1LDExN10sWzE3LDY4LDQyXSxbMTcsNTAsMjIsNiw1MSwyM10sWzE5LDQ2LDE2
LDYsNDcsMTddLFsyLDEzOSwxMTEsNywxNDAsMTEyXSxbMTcsNzQsNDZdLFs3LDU0LDI0LDE2LDU1
LDI1XSxbMzQsMzcsMTNdLFs0LDE1MSwxMjEsNSwxNTIsMTIyXSxbNCw3NSw0NywxNCw3Niw0OF0s
WzExLDU0LDI0LDE0LDU1LDI1XSxbMTYsNDUsMTUsMTQsNDYsMTZdLFs2LDE0NywxMTcsNCwxNDgs
MTE4XSxbNiw3Myw0NSwxNCw3NCw0Nl0sWzExLDU0LDI0LDE2LDU1LDI1XSxbMzAsNDYsMTYsMiw0
NywxN10sWzgsMTMyLDEwNiw0LDEzMywxMDddLFs4LDc1LDQ3LDEzLDc2LDQ4XSxbNyw1NCwyNCwy
Miw1NSwyNV0sWzIyLDQ1LDE1LDEzLDQ2LDE2XSxbMTAsMTQyLDExNCwyLDE0MywxMTVdLFsxOSw3
NCw0Niw0LDc1LDQ3XSxbMjgsNTAsMjIsNiw1MSwyM10sWzMzLDQ2LDE2LDQsNDcsMTddLFs4LDE1
MiwxMjIsNCwxNTMsMTIzXSxbMjIsNzMsNDUsMyw3NCw0Nl0sWzgsNTMsMjMsMjYsNTQsMjRdLFsx
Miw0NSwxNSwyOCw0NiwxNl0sWzMsMTQ3LDExNywxMCwxNDgsMTE4XSxbMyw3Myw0NSwyMyw3NCw0
Nl0sWzQsNTQsMjQsMzEsNTUsMjVdLFsxMSw0NSwxNSwzMSw0NiwxNl0sWzcsMTQ2LDExNiw3LDE0
NywxMTddLFsyMSw3Myw0NSw3LDc0LDQ2XSxbMSw1MywyMywzNyw1NCwyNF0sWzE5LDQ1LDE1LDI2
LDQ2LDE2XSxbNSwxNDUsMTE1LDEwLDE0NiwxMTZdLFsxOSw3NSw0NywxMCw3Niw0OF0sWzE1LDU0
LDI0LDI1LDU1LDI1XSxbMjMsNDUsMTUsMjUsNDYsMTZdLFsxMywxNDUsMTE1LDMsMTQ2LDExNl0s
WzIsNzQsNDYsMjksNzUsNDddLFs0Miw1NCwyNCwxLDU1LDI1XSxbMjMsNDUsMTUsMjgsNDYsMTZd
LFsxNywxNDUsMTE1XSxbMTAsNzQsNDYsMjMsNzUsNDddLFsxMCw1NCwyNCwzNSw1NSwyNV0sWzE5
LDQ1LDE1LDM1LDQ2LDE2XSxbMTcsMTQ1LDExNSwxLDE0NiwxMTZdLFsxNCw3NCw0NiwyMSw3NSw0
N10sWzI5LDU0LDI0LDE5LDU1LDI1XSxbMTEsNDUsMTUsNDYsNDYsMTZdLFsxMywxNDUsMTE1LDYs
MTQ2LDExNl0sWzE0LDc0LDQ2LDIzLDc1LDQ3XSxbNDQsNTQsMjQsNyw1NSwyNV0sWzU5LDQ2LDE2
LDEsNDcsMTddLFsxMiwxNTEsMTIxLDcsMTUyLDEyMl0sWzEyLDc1LDQ3LDI2LDc2LDQ4XSxbMzks
NTQsMjQsMTQsNTUsMjVdLFsyMiw0NSwxNSw0MSw0NiwxNl0sWzYsMTUxLDEyMSwxNCwxNTIsMTIy
XSxbNiw3NSw0NywzNCw3Niw0OF0sWzQ2LDU0LDI0LDEwLDU1LDI1XSxbMiw0NSwxNSw2NCw0Niwx
Nl0sWzE3LDE1MiwxMjIsNCwxNTMsMTIzXSxbMjksNzQsNDYsMTQsNzUsNDddLFs0OSw1NCwyNCwx
MCw1NSwyNV0sWzI0LDQ1LDE1LDQ2LDQ2LDE2XSxbNCwxNTIsMTIyLDE4LDE1MywxMjNdLFsxMyw3
NCw0NiwzMiw3NSw0N10sWzQ4LDU0LDI0LDE0LDU1LDI1XSxbNDIsNDUsMTUsMzIsNDYsMTZdLFsy
MCwxNDcsMTE3LDQsMTQ4LDExOF0sWzQwLDc1LDQ3LDcsNzYsNDhdLFs0Myw1NCwyNCwyMiw1NSwy
NV0sWzEwLDQ1LDE1LDY3LDQ2LDE2XSxbMTksMTQ4LDExOCw2LDE0OSwxMTldLFsxOCw3NSw0Nywz
MSw3Niw0OF0sWzM0LDU0LDI0LDM0LDU1LDI1XSxbMjAsNDUsMTUsNjEsNDYsMTZdXSxqLmdldFJT
QmxvY2tzPWZ1bmN0aW9uKGEsYil7dmFyIGM9ai5nZXRSc0Jsb2NrVGFibGUoYSxiKTtpZih2b2lk
IDA9PWMpdGhyb3cgbmV3IEVycm9yKCJiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOiIrYSsiL2Vy
cm9yQ29ycmVjdExldmVsOiIrYik7Zm9yKHZhciBkPWMubGVuZ3RoLzMsZT1bXSxmPTA7ZD5mO2Yr
Kylmb3IodmFyIGc9Y1szKmYrMF0saD1jWzMqZisxXSxpPWNbMypmKzJdLGs9MDtnPms7aysrKWUu
cHVzaChuZXcgaihoLGkpKTtyZXR1cm4gZX0sai5nZXRSc0Jsb2NrVGFibGU9ZnVuY3Rpb24oYSxi
KXtzd2l0Y2goYil7Y2FzZSBkLkw6cmV0dXJuIGouUlNfQkxPQ0tfVEFCTEVbNCooYS0xKSswXTtj
YXNlIGQuTTpyZXR1cm4gai5SU19CTE9DS19UQUJMRVs0KihhLTEpKzFdO2Nhc2UgZC5ROnJldHVy
biBqLlJTX0JMT0NLX1RBQkxFWzQqKGEtMSkrMl07Y2FzZSBkLkg6cmV0dXJuIGouUlNfQkxPQ0tf
VEFCTEVbNCooYS0xKSszXTtkZWZhdWx0OnJldHVybiB2b2lkIDB9fSxrLnByb3RvdHlwZT17Z2V0
OmZ1bmN0aW9uKGEpe3ZhciBiPU1hdGguZmxvb3IoYS84KTtyZXR1cm4gMT09KDEmdGhpcy5idWZm
ZXJbYl0+Pj43LWElOCl9LHB1dDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2I+YztjKyspdGhp
cy5wdXRCaXQoMT09KDEmYT4+PmItYy0xKSl9LGdldExlbmd0aEluQml0czpmdW5jdGlvbigpe3Jl
dHVybiB0aGlzLmxlbmd0aH0scHV0Qml0OmZ1bmN0aW9uKGEpe3ZhciBiPU1hdGguZmxvb3IodGhp
cy5sZW5ndGgvOCk7dGhpcy5idWZmZXIubGVuZ3RoPD1iJiZ0aGlzLmJ1ZmZlci5wdXNoKDApLGEm
Jih0aGlzLmJ1ZmZlcltiXXw9MTI4Pj4+dGhpcy5sZW5ndGglOCksdGhpcy5sZW5ndGgrK319O3Zh
ciBsPVtbMTcsMTQsMTEsN10sWzMyLDI2LDIwLDE0XSxbNTMsNDIsMzIsMjRdLFs3OCw2Miw0Niwz
NF0sWzEwNiw4NCw2MCw0NF0sWzEzNCwxMDYsNzQsNThdLFsxNTQsMTIyLDg2LDY0XSxbMTkyLDE1
MiwxMDgsODRdLFsyMzAsMTgwLDEzMCw5OF0sWzI3MSwyMTMsMTUxLDExOV0sWzMyMSwyNTEsMTc3
LDEzN10sWzM2NywyODcsMjAzLDE1NV0sWzQyNSwzMzEsMjQxLDE3N10sWzQ1OCwzNjIsMjU4LDE5
NF0sWzUyMCw0MTIsMjkyLDIyMF0sWzU4Niw0NTAsMzIyLDI1MF0sWzY0NCw1MDQsMzY0LDI4MF0s
WzcxOCw1NjAsMzk0LDMxMF0sWzc5Miw2MjQsNDQyLDMzOF0sWzg1OCw2NjYsNDgyLDM4Ml0sWzky
OSw3MTEsNTA5LDQwM10sWzEwMDMsNzc5LDU2NSw0MzldLFsxMDkxLDg1Nyw2MTEsNDYxXSxbMTE3
MSw5MTEsNjYxLDUxMV0sWzEyNzMsOTk3LDcxNSw1MzVdLFsxMzY3LDEwNTksNzUxLDU5M10sWzE0
NjUsMTEyNSw4MDUsNjI1XSxbMTUyOCwxMTkwLDg2OCw2NThdLFsxNjI4LDEyNjQsOTA4LDY5OF0s
WzE3MzIsMTM3MCw5ODIsNzQyXSxbMTg0MCwxNDUyLDEwMzAsNzkwXSxbMTk1MiwxNTM4LDExMTIs
ODQyXSxbMjA2OCwxNjI4LDExNjgsODk4XSxbMjE4OCwxNzIyLDEyMjgsOTU4XSxbMjMwMywxODA5
LDEyODMsOTgzXSxbMjQzMSwxOTExLDEzNTEsMTA1MV0sWzI1NjMsMTk4OSwxNDIzLDEwOTNdLFsy
Njk5LDIwOTksMTQ5OSwxMTM5XSxbMjgwOSwyMjEzLDE1NzksMTIxOV0sWzI5NTMsMjMzMSwxNjYz
LDEyNzNdXSxvPWZ1bmN0aW9uKCl7dmFyIGE9ZnVuY3Rpb24oYSxiKXt0aGlzLl9lbD1hLHRoaXMu
X2h0T3B0aW9uPWJ9O3JldHVybiBhLnByb3RvdHlwZS5kcmF3PWZ1bmN0aW9uKGEpe2Z1bmN0aW9u
IGcoYSxiKXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3Jn
LzIwMDAvc3ZnIixhKTtmb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiZjLnNldEF0
dHJpYnV0ZShkLGJbZF0pO3JldHVybiBjfXZhciBiPXRoaXMuX2h0T3B0aW9uLGM9dGhpcy5fZWws
ZD1hLmdldE1vZHVsZUNvdW50KCk7TWF0aC5mbG9vcihiLndpZHRoL2QpLE1hdGguZmxvb3IoYi5o
ZWlnaHQvZCksdGhpcy5jbGVhcigpO3ZhciBoPWcoInN2ZyIse3ZpZXdCb3g6IjAgMCAiK1N0cmlu
ZyhkKSsiICIrU3RyaW5nKGQpLHdpZHRoOiIxMDAlIixoZWlnaHQ6IjEwMCUiLGZpbGw6Yi5jb2xv
ckxpZ2h0fSk7aC5zZXRBdHRyaWJ1dGVOUygiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8i
LCJ4bWxuczp4bGluayIsImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiKSxjLmFwcGVuZENo
aWxkKGgpLGguYXBwZW5kQ2hpbGQoZygicmVjdCIse2ZpbGw6Yi5jb2xvckRhcmssd2lkdGg6IjEi
LGhlaWdodDoiMSIsaWQ6InRlbXBsYXRlIn0pKTtmb3IodmFyIGk9MDtkPmk7aSsrKWZvcih2YXIg
aj0wO2Q+ajtqKyspaWYoYS5pc0RhcmsoaSxqKSl7dmFyIGs9ZygidXNlIix7eDpTdHJpbmcoaSks
eTpTdHJpbmcoail9KTtrLnNldEF0dHJpYnV0ZU5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs
aW5rIiwiaHJlZiIsIiN0ZW1wbGF0ZSIpLGguYXBwZW5kQ2hpbGQoayl9fSxhLnByb3RvdHlwZS5j
bGVhcj1mdW5jdGlvbigpe2Zvcig7dGhpcy5fZWwuaGFzQ2hpbGROb2RlcygpOyl0aGlzLl9lbC5y
ZW1vdmVDaGlsZCh0aGlzLl9lbC5sYXN0Q2hpbGQpfSxhfSgpLHA9InN2ZyI9PT1kb2N1bWVudC5k
b2N1bWVudEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLHE9cD9vOm0oKT9mdW5jdGlvbigp
e2Z1bmN0aW9uIGEoKXt0aGlzLl9lbEltYWdlLnNyYz10aGlzLl9lbENhbnZhcy50b0RhdGFVUkwo
ImltYWdlL3BuZyIpLHRoaXMuX2VsSW1hZ2Uuc3R5bGUuZGlzcGxheT0iYmxvY2siLHRoaXMuX2Vs
Q2FudmFzLnN0eWxlLmRpc3BsYXk9Im5vbmUifWZ1bmN0aW9uIGQoYSxiKXt2YXIgYz10aGlzO2lm
KGMuX2ZGYWlsPWIsYy5fZlN1Y2Nlc3M9YSxudWxsPT09Yy5fYlN1cHBvcnREYXRhVVJJKXt2YXIg
ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKSxlPWZ1bmN0aW9uKCl7Yy5fYlN1cHBvcnRE
YXRhVVJJPSExLGMuX2ZGYWlsJiZfZkZhaWwuY2FsbChjKX0sZj1mdW5jdGlvbigpe2MuX2JTdXBw
b3J0RGF0YVVSST0hMCxjLl9mU3VjY2VzcyYmYy5fZlN1Y2Nlc3MuY2FsbChjKX07cmV0dXJuIGQu
b25hYm9ydD1lLGQub25lcnJvcj1lLGQub25sb2FkPWYsZC5zcmM9ImRhdGE6aW1hZ2UvZ2lmO2Jh
c2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBRkNBWUFBQUNOYnlibEFBQUFIRWxF
UVZRSTEyUDQvLzgvdzM4R0lBWERJQktFMERIeGdsak5CQUFPOVRYTDBZNE9Id0FBQUFCSlJVNUVy
a0pnZ2c9PSIsdm9pZCAwfWMuX2JTdXBwb3J0RGF0YVVSST09PSEwJiZjLl9mU3VjY2Vzcz9jLl9m
U3VjY2Vzcy5jYWxsKGMpOmMuX2JTdXBwb3J0RGF0YVVSST09PSExJiZjLl9mRmFpbCYmYy5fZkZh
aWwuY2FsbChjKX1pZih0aGlzLl9hbmRyb2lkJiZ0aGlzLl9hbmRyb2lkPD0yLjEpe3ZhciBiPTEv
d2luZG93LmRldmljZVBpeGVsUmF0aW8sYz1DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90
eXBlLmRyYXdJbWFnZTtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmRyYXdJbWFn
ZT1mdW5jdGlvbihhLGQsZSxmLGcsaCxpLGope2lmKCJub2RlTmFtZSJpbiBhJiYvaW1nL2kudGVz
dChhLm5vZGVOYW1lKSlmb3IodmFyIGw9YXJndW1lbnRzLmxlbmd0aC0xO2w+PTE7bC0tKWFyZ3Vt
ZW50c1tsXT1hcmd1bWVudHNbbF0qYjtlbHNlInVuZGVmaW5lZCI9PXR5cGVvZiBqJiYoYXJndW1l
bnRzWzFdKj1iLGFyZ3VtZW50c1syXSo9Yixhcmd1bWVudHNbM10qPWIsYXJndW1lbnRzWzRdKj1i
KTtjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIGU9ZnVuY3Rpb24oYSxiKXt0aGlzLl9iSXNQ
YWludGVkPSExLHRoaXMuX2FuZHJvaWQ9bigpLHRoaXMuX2h0T3B0aW9uPWIsdGhpcy5fZWxDYW52
YXM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiY2FudmFzIiksdGhpcy5fZWxDYW52YXMud2lkdGg9
Yi53aWR0aCx0aGlzLl9lbENhbnZhcy5oZWlnaHQ9Yi5oZWlnaHQsYS5hcHBlbmRDaGlsZCh0aGlz
Ll9lbENhbnZhcyksdGhpcy5fZWw9YSx0aGlzLl9vQ29udGV4dD10aGlzLl9lbENhbnZhcy5nZXRD
b250ZXh0KCIyZCIpLHRoaXMuX2JJc1BhaW50ZWQ9ITEsdGhpcy5fZWxJbWFnZT1kb2N1bWVudC5j
cmVhdGVFbGVtZW50KCJpbWciKSx0aGlzLl9lbEltYWdlLnN0eWxlLmRpc3BsYXk9Im5vbmUiLHRo
aXMuX2VsLmFwcGVuZENoaWxkKHRoaXMuX2VsSW1hZ2UpLHRoaXMuX2JTdXBwb3J0RGF0YVVSST1u
dWxsfTtyZXR1cm4gZS5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLl9lbElt
YWdlLGM9dGhpcy5fb0NvbnRleHQsZD10aGlzLl9odE9wdGlvbixlPWEuZ2V0TW9kdWxlQ291bnQo
KSxmPWQud2lkdGgvZSxnPWQuaGVpZ2h0L2UsaD1NYXRoLnJvdW5kKGYpLGk9TWF0aC5yb3VuZChn
KTtiLnN0eWxlLmRpc3BsYXk9Im5vbmUiLHRoaXMuY2xlYXIoKTtmb3IodmFyIGo9MDtlPmo7aisr
KWZvcih2YXIgaz0wO2U+aztrKyspe3ZhciBsPWEuaXNEYXJrKGosayksbT1rKmYsbj1qKmc7Yy5z
dHJva2VTdHlsZT1sP2QuY29sb3JEYXJrOmQuY29sb3JMaWdodCxjLmxpbmVXaWR0aD0xLGMuZmls
bFN0eWxlPWw/ZC5jb2xvckRhcms6ZC5jb2xvckxpZ2h0LGMuZmlsbFJlY3QobSxuLGYsZyksYy5z
dHJva2VSZWN0KE1hdGguZmxvb3IobSkrLjUsTWF0aC5mbG9vcihuKSsuNSxoLGkpLGMuc3Ryb2tl
UmVjdChNYXRoLmNlaWwobSktLjUsTWF0aC5jZWlsKG4pLS41LGgsaSl9dGhpcy5fYklzUGFpbnRl
ZD0hMH0sZS5wcm90b3R5cGUubWFrZUltYWdlPWZ1bmN0aW9uKCl7dGhpcy5fYklzUGFpbnRlZCYm
ZC5jYWxsKHRoaXMsYSl9LGUucHJvdG90eXBlLmlzUGFpbnRlZD1mdW5jdGlvbigpe3JldHVybiB0
aGlzLl9iSXNQYWludGVkfSxlLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuX29Db250
ZXh0LmNsZWFyUmVjdCgwLDAsdGhpcy5fZWxDYW52YXMud2lkdGgsdGhpcy5fZWxDYW52YXMuaGVp
Z2h0KSx0aGlzLl9iSXNQYWludGVkPSExfSxlLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbihhKXty
ZXR1cm4gYT9NYXRoLmZsb29yKDFlMyphKS8xZTM6YX0sZX0oKTpmdW5jdGlvbigpe3ZhciBhPWZ1
bmN0aW9uKGEsYil7dGhpcy5fZWw9YSx0aGlzLl9odE9wdGlvbj1ifTtyZXR1cm4gYS5wcm90b3R5
cGUuZHJhdz1mdW5jdGlvbihhKXtmb3IodmFyIGI9dGhpcy5faHRPcHRpb24sYz10aGlzLl9lbCxk
PWEuZ2V0TW9kdWxlQ291bnQoKSxlPU1hdGguZmxvb3IoYi53aWR0aC9kKSxmPU1hdGguZmxvb3Io
Yi5oZWlnaHQvZCksZz1bJzx0YWJsZSBzdHlsZT0iYm9yZGVyOjA7Ym9yZGVyLWNvbGxhcHNlOmNv
bGxhcHNlOyI+J10saD0wO2Q+aDtoKyspe2cucHVzaCgiPHRyPiIpO2Zvcih2YXIgaT0wO2Q+aTtp
KyspZy5wdXNoKCc8dGQgc3R5bGU9ImJvcmRlcjowO2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTtw
YWRkaW5nOjA7bWFyZ2luOjA7d2lkdGg6JytlKyJweDtoZWlnaHQ6IitmKyJweDtiYWNrZ3JvdW5k
LWNvbG9yOiIrKGEuaXNEYXJrKGgsaSk/Yi5jb2xvckRhcms6Yi5jb2xvckxpZ2h0KSsnOyI+PC90
ZD4nKTtnLnB1c2goIjwvdHI+Iil9Zy5wdXNoKCI8L3RhYmxlPiIpLGMuaW5uZXJIVE1MPWcuam9p
bigiIik7dmFyIGo9Yy5jaGlsZE5vZGVzWzBdLGs9KGIud2lkdGgtai5vZmZzZXRXaWR0aCkvMixs
PShiLmhlaWdodC1qLm9mZnNldEhlaWdodCkvMjtrPjAmJmw+MCYmKGouc3R5bGUubWFyZ2luPWwr
InB4ICIraysicHgiKX0sYS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLl9lbC5pbm5l
ckhUTUw9IiJ9LGF9KCk7UVJDb2RlPWZ1bmN0aW9uKGEsYil7aWYodGhpcy5faHRPcHRpb249e3dp
ZHRoOjI1NixoZWlnaHQ6MjU2LHR5cGVOdW1iZXI6NCxjb2xvckRhcms6IiMwMDAwMDAiLGNvbG9y
TGlnaHQ6IiNmZmZmZmYiLGNvcnJlY3RMZXZlbDpkLkh9LCJzdHJpbmciPT10eXBlb2YgYiYmKGI9
e3RleHQ6Yn0pLGIpZm9yKHZhciBjIGluIGIpdGhpcy5faHRPcHRpb25bY109YltjXTsic3RyaW5n
Ij09dHlwZW9mIGEmJihhPWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGEpKSx0aGlzLl9hbmRyb2lk
PW4oKSx0aGlzLl9lbD1hLHRoaXMuX29RUkNvZGU9bnVsbCx0aGlzLl9vRHJhd2luZz1uZXcgcSh0
aGlzLl9lbCx0aGlzLl9odE9wdGlvbiksdGhpcy5faHRPcHRpb24udGV4dCYmdGhpcy5tYWtlQ29k
ZSh0aGlzLl9odE9wdGlvbi50ZXh0KX0sUVJDb2RlLnByb3RvdHlwZS5tYWtlQ29kZT1mdW5jdGlv
bihhKXt0aGlzLl9vUVJDb2RlPW5ldyBiKHIoYSx0aGlzLl9odE9wdGlvbi5jb3JyZWN0TGV2ZWwp
LHRoaXMuX2h0T3B0aW9uLmNvcnJlY3RMZXZlbCksdGhpcy5fb1FSQ29kZS5hZGREYXRhKGEpLHRo
aXMuX29RUkNvZGUubWFrZSgpLHRoaXMuX2VsLnRpdGxlPWEsdGhpcy5fb0RyYXdpbmcuZHJhdyh0
aGlzLl9vUVJDb2RlKSx0aGlzLm1ha2VJbWFnZSgpfSxRUkNvZGUucHJvdG90eXBlLm1ha2VJbWFn
ZT1mdW5jdGlvbigpeyJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLl9vRHJhd2luZy5tYWtlSW1hZ2Um
JighdGhpcy5fYW5kcm9pZHx8dGhpcy5fYW5kcm9pZD49MykmJnRoaXMuX29EcmF3aW5nLm1ha2VJ
bWFnZSgpfSxRUkNvZGUucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5fb0RyYXdpbmcu
Y2xlYXIoKX0sUVJDb2RlLkNvcnJlY3RMZXZlbD1kfSgpOw==
`;
const base64UrlEncode = value => {
        const encoded = btoa(unescape(encodeURIComponent(value)));
        return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
      };

      const base64UrlDecode = value => {
        let normalized = value.replace(/-/g, '+').replace(/_/g, '/');
        while (normalized.length % 4) {
          normalized += '=';
        }
        return decodeURIComponent(escape(atob(normalized)));
      };

      function ensureQrLibrary() {
        if (qrLibraryLoaded && window.QRCode) {
          return;
        }
        const qrScript = atob(qrLibBase64.replace(/\s+/g, ''));
        const scriptEl = document.createElement('script');
        scriptEl.type = 'text/javascript';
        scriptEl.text = qrScript;
        document.head.appendChild(scriptEl);
        qrLibraryLoaded = true;
      }

      const promptUnavailableNoticeMessage = "You can't start chatting until you set an LLM API endpoint.";

      const triggerEndpointGuidance = () => {
        showToast(promptUnavailableNoticeMessage);
        guideToEndpointSetup();
      };

      if (chatNotice) {
        chatNotice.addEventListener('click', () => {
          if (!chatNotice.classList.contains('requires-endpoint')) {
            return;
          }
          triggerEndpointGuidance();
        });
        chatNotice.addEventListener('keydown', event => {
          if (!chatNotice.classList.contains('requires-endpoint')) {
            return;
          }
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            triggerEndpointGuidance();
          }
        });
      }

      const defaults = { endpoint: '', token: '', model: '' };
      const CONFIG_KEY = 'chatConfig';
      const THREAD_KEY = 'chatThreads';
      const MODELS_KEY = 'chatModels';

      if (tokenInput) {
        const setTokenMasked = masked => {
          tokenInput.classList.toggle('masked', masked);
          if (peekTokenBtn) {
            const label = masked ? 'Show token' : 'Hide token';
            peekTokenBtn.setAttribute('aria-pressed', String(!masked));
            peekTokenBtn.setAttribute('aria-label', label);
            peekTokenBtn.setAttribute('title', label);
            const iconUse = peekTokenBtn.querySelector('use');
            if (iconUse) {
              iconUse.setAttribute('href', masked ? '#icon-eye' : '#icon-eye-off');
            }
          }
        };

        setTokenMasked(true);

        if (peekTokenBtn) {
          peekTokenBtn.addEventListener('click', () => {
            setTokenMasked(!tokenInput.classList.contains('masked'));
          });
        }

        if (copyTokenBtn) {
          copyTokenBtn.addEventListener('click', async () => {
            const value = tokenInput.value || '';
            if (!value) {
              showToast('Token field is empty');
              return;
            }

            if (navigator.clipboard && navigator.clipboard.writeText) {
              try {
                await navigator.clipboard.writeText(value);
                showToast('Token copied to clipboard');
                return;
              } catch (error) {
                console.warn('Clipboard write failed', error);
              }
            }

            window.prompt('Copy token', value);
          });
        }
      }

      const endpointOptions = [
        {
          id: 'choose',
          label: 'Select an endpoint…',
          baseUrl: '',
          hint:
            'Pick a provider from the list to auto-fill the API endpoint and see instructions for locating its API key. You can still paste any custom endpoint below. Requests use <code>/chat/completions</code> for the configured base URL.'
        },
        {
          id: 'openai',
          label: 'OpenAI',
          baseUrl: 'https://api.openai.com/v1',
          hint:
            'Access GPT-4o and other OpenAI models. Sign in at <a href="https://platform.openai.com/" target="_blank" rel="noopener">platform.openai.com</a>, open <strong>API keys</strong>, click <strong>Create new secret key</strong>, name it, and copy the value immediately (it is shown only once). Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'openrouter',
          label: 'OpenRouter — multi-model hub',
          baseUrl: 'https://openrouter.ai/api/v1',
          hint:
            'Aggregator of Anthropic, Mistral, Llama 3 and more. Create an account at <a href="https://openrouter.ai/" target="_blank" rel="noopener">openrouter.ai</a>, open <strong>API Keys</strong>, click <strong>Create Key</strong>, set an optional spend limit, and copy the key (it is shown only once). Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'vercel',
          label: 'Vercel AI Gateway',
          baseUrl: 'https://ai-gateway.vercel.sh/v1',
          hint:
            'Proxy that fans out to Anthropic, Groq, Mistral, Perplexity and more. In the Vercel dashboard go to <strong>AI Gateway → API Keys</strong>, click <strong>Create key</strong>, name it, and copy the generated key for your requests. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'cloudflare',
          label: 'Cloudflare AI Gateway',
          baseUrl: 'https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/compat',
          hint:
            'Routes to Gemini, Cohere, Perplexity and other providers. In the Cloudflare dashboard open <strong>AI → AI Gateway</strong>, choose your gateway, add provider API keys under <strong>Provider Keys</strong>, and optionally generate an access token to send in the <code>cf-aig-authorization</code> header. Use this base URL; the client calls <code>/chat/completions</code> automatically.',
          detect: value => value.startsWith('https://gateway.ai.cloudflare.com/')
        },
        {
          id: 'anyscale',
          label: 'Anyscale Endpoints',
          baseUrl: 'https://api.endpoints.anyscale.com/v1',
          hint:
            'Hosted Mixtral and Llama family models. Sign in at <a href="https://www.anyscale.com/" target="_blank" rel="noopener">Anyscale</a>, open the Endpoints dashboard, and create an API key to authenticate with this URL. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'groq',
          label: 'Groq — low-latency inference',
          baseUrl: 'https://api.groq.com/openai/v1',
          hint:
            'Runs LLaMA and Mixtral models on Groq hardware. After logging in to <a href="https://console.groq.com/" target="_blank" rel="noopener">Groq Cloud</a>, open <strong>Developers</strong>, click <strong>Create API Key</strong>, and copy the key when it appears. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'together',
          label: 'Together AI',
          baseUrl: 'https://api.together.xyz/v1',
          hint:
            'Unified endpoint for Meta, Mistral, DeepSeek, Google and more. Create an account at <a href="https://api.together.xyz/" target="_blank" rel="noopener">Together AI</a>, visit <strong>Settings → API Keys</strong>, generate a key, and paste it here. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'fireworks',
          label: 'Fireworks AI',
          baseUrl: 'https://api.fireworks.ai/inference/v1',
          hint:
            'Fireworks hosts Mixtral-based instruct models and other OSS LLMs. In the Fireworks dashboard open <strong>API Keys</strong>, click <strong>Create API Key</strong>, and copy the value for use with this endpoint. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'deepseek',
          label: 'DeepSeek',
          baseUrl: 'https://api.deepseek.com',
          hint:
            'Access DeepSeek’s reasoning models. Sign in to <a href="https://platform.deepseek.com/" target="_blank" rel="noopener">DeepSeek</a>, choose <strong>Access API → API Keys</strong>, create a key, and store it securely because it is only shown once. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'hyperbolic',
          label: 'Hyperbolic',
          baseUrl: 'https://api.hyperbolic.xyz/v1',
          hint:
            'Scaled-down OSS models with OpenAI compatibility. Log in to Hyperbolic, create an API key in your dashboard, and use it alongside this base URL. The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'deepinfra',
          label: 'DeepInfra',
          baseUrl: 'https://api.deepinfra.com/v1/openai',
          hint:
            'Chat, completion, and embedding APIs for open-source LLMs. Generate an API key from the <a href="https://deepinfra.com/" target="_blank" rel="noopener">DeepInfra</a> console and include it in the <code>Authorization</code> header. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'perplexity',
          label: 'Perplexity Sonar',
          baseUrl: 'https://api.perplexity.ai',
          hint:
            'Grounded web-search models with an OpenAI-style API. From the Perplexity account dashboard create an API key, then use it with this endpoint. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'huggingface-router',
          label: 'Hugging Face router',
          baseUrl: 'https://router.huggingface.co/v1',
          hint:
            'Route to providers like Novita, Groq or Together via the model name. Create or reuse a Hugging Face access token at <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener">huggingface.co/settings/tokens</a> and pass it as your API key. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'huggingface-tgi',
          label: 'Hugging Face TGI (local)',
          baseUrl: 'http://localhost:8080/v1',
          hint:
            'Run <strong>text-generation-inference</strong> locally and point the client at this base URL. No API key is required when running on your own machine, and the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'lorax',
          label: 'LoRAX (local server)',
          baseUrl: 'http://127.0.0.1:8080/v1',
          hint:
            'LoRAX exposes an OpenAI-compatible endpoint on your workstation. Start the server and use any placeholder key if authentication is disabled. The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'lmstudio',
          label: 'LM Studio (desktop)',
          baseUrl: 'http://localhost:1234/v1',
          hint:
            'LM Studio ships with an OpenAI-compatible API. Start the local server from the LM Studio interface and use this URL (the API key field can stay empty). The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'ollama',
          label: 'Ollama (local)',
          baseUrl: 'http://localhost:11434/v1',
          hint:
            'Ollama serves local LLaMA, Mistral and Phi models. No API key is required—any string will work—so you can leave the token blank. The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'runpod',
          label: 'RunPod vLLM worker',
          baseUrl: 'https://api.runpod.ai/v2/ENDPOINT_ID/openai/v1',
          hint:
            'Each RunPod worker exposes an OpenAI-compatible interface. Replace <code>ENDPOINT_ID</code> with your worker ID and use the API key from the RunPod dashboard. Use this base URL; the client calls <code>/chat/completions</code> automatically.',
          detect: value => value.startsWith('https://api.runpod.ai/v2/')
        },
        {
          id: 'baseten',
          label: 'Baseten (model-specific URL)',
          baseUrl: 'https://{model_id}.api.baseten.co/environments/{environment}/content/v1',
          hint:
            'Deploy models with Engine Builder to receive an OpenAI-style endpoint. Use the format <code>https://{model_id}.api.baseten.co/environments/&lt;env&gt;/content/v1</code> and authenticate with a Baseten personal API key created from <strong>Account → API keys</strong>. Use this base URL; the client calls <code>/chat/completions</code> automatically.',
          detect: value => value.includes('.api.baseten.co')
        },
        {
          id: 'custom',
          label: 'Custom / self-hosted endpoint',
          baseUrl: '',
          hint:
            'Paste any OpenAI-compatible base URL, such as a corporate gateway or another local server. Remember to include the provider’s API key (if required). Changes save automatically as you edit. Requests use <code>/chat/completions</code> for this base URL.'
        }
      ];

      const escapeHtml = str =>
        (str || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');

      function getEndpointOptionById(id) {
        return endpointOptions.find(option => option.id === id) || endpointOptions[0];
      }

      function findEndpointOptionForValue(value) {
        const normalized = (value || '').trim().toLowerCase();
        if (!normalized) {
          return getEndpointOptionById('choose');
        }
        const match = endpointOptions.find(option => {
          if (option.baseUrl) {
            const compare = option.baseUrl.toLowerCase();
            if (compare && normalized.startsWith(compare)) {
              return true;
            }
          }
          if (typeof option.detect === 'function') {
            try {
              if (option.detect(normalized)) {
                return true;
              }
            } catch (err) {
              console.warn('Endpoint detection failed for option', option.id, err);
            }
          }
          return false;
        });
        return match || getEndpointOptionById('custom');
      }

      function updateEndpointHint(option, currentValue) {
        if (!endpointHint) return;
        const target = option || getEndpointOptionById('choose');
        let html = target.hint || '';
        if (target.id === 'custom' && currentValue) {
          html += `<br /><strong>Using:</strong> <code>${escapeHtml(currentValue)}</code>`;
        } else if (target.baseUrl) {
          html += `<br /><strong>Endpoint URL:</strong> <code>${escapeHtml(target.baseUrl)}</code>`;
        }
        if (!html) {
          endpointHint.textContent = '';
          endpointHint.hidden = true;
        } else {
          endpointHint.innerHTML = html;
          endpointHint.hidden = false;
        }
      }

      function syncEndpointControls(value) {
        const option = findEndpointOptionForValue(value);
        if (endpointSelect) {
          endpointSelect.value = option.id;
        }
        updateEndpointHint(option, value);
      }

      function persistEndpointValue(value, { refresh = false } = {}) {
        const normalized = (value || '').trim();
        if (config.endpoint !== normalized) {
          config.endpoint = normalized;
          persistConfig();
        }
        syncEndpointControls(normalized);
        updateChatAvailability();
        consecutiveAuthErrors = 0;
        updateAuthGuidance();
        if (refresh) {
          refreshModels({ silent: true });
        }
      }

      function persistTokenValue(value, { refresh = false } = {}) {
        const normalized = (value || '').trim();
        if (config.token !== normalized) {
          config.token = normalized;
          persistConfig();
        }
        consecutiveAuthErrors = 0;
        updateAuthGuidance();
        if (refresh) {
          refreshModels({ silent: true });
        }
      }

      function applyEndpointOption(optionId) {
        const option = getEndpointOptionById(optionId);
        if (!option) return;
        if (option.id === 'choose') {
          endpointInput.value = '';
        } else if (option.baseUrl) {
          endpointInput.value = option.baseUrl;
        }
        persistEndpointValue(endpointInput.value, { refresh: true });
      }

      function populateEndpointSelect() {
        if (!endpointSelect) return;
        endpointSelect.innerHTML = '';
        endpointOptions.forEach(option => {
          const opt = document.createElement('option');
          opt.value = option.id;
          opt.textContent = option.label;
          endpointSelect.appendChild(opt);
        });
        const currentValue = endpointInput ? endpointInput.value.trim() : '';
        syncEndpointControls(currentValue);
      }

      const readJson = (store, key, fallback) => {
        try {
          const raw = store.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch (err) {
          console.warn(`Could not read ${key}:`, err);
          return fallback;
        }
      };

      const writeJson = (store, key, value) => {
        try {
          store.setItem(key, JSON.stringify(value));
        } catch (err) {
          console.error(`Failed to write ${key}:`, err);
        }
      };

      const persistConfig = () => writeJson(sessionStorage, CONFIG_KEY, config);

      function openModal(modalEl, { focusEl, triggerEl } = {}) {
        if (!modalEl || !modalBackdrop) {
          return;
        }
        activeModal = modalEl;
        activeModalTrigger = triggerEl || null;
        modalEl.hidden = false;
        modalBackdrop.hidden = false;
        document.body.style.overflow = 'hidden';
        if (focusEl) {
          focusEl.focus();
        }
      }

      function closeModal({ returnFocus = true } = {}) {
        if (!modalBackdrop || !activeModal) {
          return;
        }
        activeModal.hidden = true;
        modalBackdrop.hidden = true;
        document.body.style.overflow = '';
        if (returnFocus && activeModalTrigger) {
          activeModalTrigger.focus();
        }
        activeModal = null;
        activeModalTrigger = null;
      }

      function openAbout() {
        if (!aboutModal) return;
        if (aboutBtn) {
          aboutBtn.setAttribute('aria-expanded', 'true');
        }
        openModal(aboutModal, { focusEl: aboutCloseBtn, triggerEl: aboutBtn });
      }

      function closeAbout({ returnFocus = true } = {}) {
        if (!aboutModal) return;
        if (aboutBtn) {
          aboutBtn.setAttribute('aria-expanded', 'false');
        }
        if (activeModal === aboutModal) {
          closeModal({ returnFocus });
        } else if (!aboutModal.hidden) {
          aboutModal.hidden = true;
          if (returnFocus && aboutBtn) {
            aboutBtn.focus();
          }
        }
      }

      function maybeShowPromo() {
        if (!promoBanner) return;
        const dismissed = sessionStorage.getItem('promoDismissed') === '1';
        promoBanner.hidden = dismissed;
      }

      function buildPreloadUrl() {
        const baseHref = window.location.href.split('#')[0].split('?')[0];
        const params = new URLSearchParams();
        const title = (threadTitleInput?.value || '').trim();
        const system = (systemPromptInput?.value || '').trim();
        const prompt = (messageInput?.value || '').trim();
        if (title) params.set('title', title);
        if (system) params.set('system', system);
        if (prompt) params.set('prompt', prompt);
        const query = params.toString();
        return query ? `${baseHref}?${query}` : baseHref;
      }

      function initMarketing() {
        maybeShowPromo();
        const qs = new URLSearchParams(window.location.search);
        if (qs.get('about') === '1') {
          openAbout();
        }
      }

      function loadModels() {
        models = readJson(sessionStorage, MODELS_KEY, []);
      }

      function storeModels(list) {
        models = [...new Set(list.filter(Boolean))];
        writeJson(sessionStorage, MODELS_KEY, models);
      }

      /**
       * Render the model dropdown. If no models are loaded the select is disabled.
       * @param {string[]} list list of model ids
       * @param {string} desiredModel previously selected model
       */
      function renderModelOptions(list, desiredModel) {
        const ids = [...new Set(list.filter(Boolean))];
        modelSelect.innerHTML = '';
        if (!ids.length) {
          modelSelect.disabled = true;
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No models loaded';
          modelSelect.appendChild(option);
          if (config.model) {
            config.model = '';
            persistConfig();
          }
          updateChatAvailability();
          return;
        }

        ids.forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = id;
          modelSelect.appendChild(option);
        });

        modelSelect.disabled = false;
        const selection = ids.includes(desiredModel) ? desiredModel : ids[0];
        modelSelect.value = selection;
        if (config.model !== selection) {
          config.model = selection;
          persistConfig();
        }
        updateChatAvailability();
      }

      function loadConfig() {
        config = { ...defaults, ...readJson(sessionStorage, CONFIG_KEY, {}) };
        endpointInput.value = config.endpoint;
        tokenInput.value = config.token;
        syncEndpointControls(config.endpoint);
        renderModelOptions(models, config.model);
      }

      function loadThreads() {
        const storedThreads = readJson(localStorage, THREAD_KEY, []);
        threads = Array.isArray(storedThreads) ? storedThreads : [];
      }

      function saveThreads() {
        writeJson(localStorage, THREAD_KEY, threads);
      }

      function generateThreadId() {
        return `${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 10)}`;
      }

      function createThread({ title = 'New chat', systemPrompt = '', messages = [] } = {}) {
        const id = generateThreadId();
        const normalizedTitle = typeof title === 'string' ? title : 'New chat';
        const normalizedSystemPrompt = typeof systemPrompt === 'string' ? systemPrompt : '';
        const thread = {
          id,
          title: normalizedTitle,
          systemPrompt: normalizedSystemPrompt,
          messages: Array.isArray(messages) ? [...messages] : []
        };
        threads.push(thread);
        saveThreads();
        return id;
      }

      function ensureThreadExists() {
        const hasValidThread = threads.some(thread => thread && typeof thread.id === 'string' && thread.id);
        if (hasValidThread) {
          return null;
        }
        return createThread();
      }

      const getThread = id => threads.find(t => t.id === id);
      const currentThread = () => getThread(currentThreadId);
      const updateThread = mutator => {
        const thread = currentThread();
        if (!thread) return null;
        mutator(thread);
        saveThreads();
        return thread;
      };

      /**
       * Derive the state of the chat. A thread, endpoint and model must be selected
       * before sending messages. This helper returns booleans representing those
       * conditions as well as an aggregate "ready" flag.
       */
      function getChatState() {
        const thread = currentThread();
        const hasThread = Boolean(thread);
        const hasEndpoint = Boolean((config.endpoint || '').trim());
        const hasModel = Boolean((config.model || '').trim());
        return {
          hasThread,
          hasEndpoint,
          hasModel,
          ready: hasThread && hasEndpoint && hasModel
        };
      }

      /**
       * Enable or disable the send button depending on whether a message is ready to send.
       * @param {boolean} isReady indicates if chat conditions are met
       */
      function updateSendButtonDisabled(isReady) {
        if (!sendBtn || !messageInput) return;
        const hasContent = Boolean(messageInput.value.trim());
        sendBtn.disabled = !isReady || !hasContent || messageInput.disabled;
      }

      /**
       * Update the notice block above the chat area to indicate missing prerequisites.
       * When there are no issues this hides the notice, otherwise lists guidance.
       * @param {object} state output from getChatState()
       */
      function updateChatNotice(state) {
        if (!chatNotice) return;
        const instructions = [];
        if (!state.hasEndpoint) {
          instructions.push('Enter an API endpoint in Settings to send messages.');
        }
        if (state.hasEndpoint && !state.hasModel) {
          instructions.push('Refresh and select a model before chatting.');
        }
        if (!state.hasThread) {
          instructions.push('Create or select a chat from the sidebar.');
        }

        const requiresEndpoint = !state.hasEndpoint;
        chatNotice.classList.toggle('requires-endpoint', requiresEndpoint);
        if (requiresEndpoint) {
          chatNotice.setAttribute('tabindex', '0');
        } else {
          chatNotice.removeAttribute('tabindex');
        }

        chatNotice.innerHTML = '';
        if (!instructions.length) {
          chatNotice.classList.remove('active');
          chatNotice.setAttribute('aria-hidden', 'true');
          chatNotice.hidden = true;
          if (messageInput) {
            messageInput.removeAttribute('aria-describedby');
          }
          return;
        }

        const list = document.createElement('ul');
        instructions.forEach(text => {
          const item = document.createElement('li');
          item.textContent = text;
          list.appendChild(item);
        });
        chatNotice.appendChild(list);
        chatNotice.classList.add('active');
        chatNotice.setAttribute('aria-hidden', 'false');
        chatNotice.hidden = false;
        if (messageInput) {
          messageInput.setAttribute('aria-describedby', 'chatNotice');
        }
      }

      /**
       * Based on chat state, enable/disable inputs and update placeholders
       * to guide the user toward completing the necessary steps. When a
       * message has been prefilled via URL, we leave that value intact
       * so the user can see it even if sending is disabled.
       */
      function updateChatAvailability() {
        const state = getChatState();
        const placeholder = !state.hasThread
          ? 'Select or start a chat to enable messaging'
          : !state.hasEndpoint
            ? 'Add an API endpoint to enable messaging'
            : !state.hasModel
              ? 'Select a model to enable messaging'
              : 'Type your message';
        threadTitleInput.disabled = !state.hasThread;
        systemPromptInput.disabled = !state.hasThread;

        // Only update the message placeholder if the input is empty. If there's
        // pre-filled text we leave it alone so that the user can see it.
        if (!messageInput.value) {
          messageInput.placeholder = placeholder;
        }
        // Disable input when not ready, but leave the value alone.
        messageInput.disabled = !state.ready;
        if (state.ready) {
          messageForm.classList.remove('disabled');
          messageForm.setAttribute('aria-disabled', 'false');
        } else {
          messageForm.classList.add('disabled');
          messageForm.setAttribute('aria-disabled', 'true');
        }
        updateChatNotice(state);
        updateSendButtonDisabled(state.ready);
      }

      function hideToast() {
        if (!toast) return;
        toast.classList.remove('visible');
        toast.setAttribute('aria-hidden', 'true');
        if (toastHideTimer) {
          window.clearTimeout(toastHideTimer);
          toastHideTimer = null;
        }
        window.setTimeout(() => {
          if (!toast.classList.contains('visible')) {
            toast.hidden = true;
          }
        }, 180);
      }

      function showToast(message, duration = 3200) {
        if (!toast) return;
        if (toastHideTimer) {
          window.clearTimeout(toastHideTimer);
          toastHideTimer = null;
        }
        toast.textContent = message;
        toast.hidden = false;
        toast.setAttribute('aria-hidden', 'false');
        toast.classList.remove('visible');
        // Force reflow so the animation retriggers when showToast runs rapidly.
        void toast.offsetWidth;
        toast.classList.add('visible');
        toastHideTimer = window.setTimeout(() => {
          toastHideTimer = null;
          hideToast();
        }, duration);
      }

      /**
       * Ensure the chat history list is always tall enough to keep the "Start new chat"
       * control visible on compact screens. The minimum height is equal to the combined
       * height of the available items up to a maximum of 2.5 list items.
       */
      function updateThreadListMinHeight() {
        if (!threadList) {
          return;
        }
        const items = threadList.querySelectorAll('li');
        if (!items.length) {
          threadList.style.removeProperty('min-height');
          return;
        }

        const itemHeights = Array.from(items, item => {
          const rect = item.getBoundingClientRect();
          const styles = window.getComputedStyle(item);
          const marginTop = parseFloat(styles.marginTop) || 0;
          const marginBottom = parseFloat(styles.marginBottom) || 0;
          return rect.height + marginTop + marginBottom;
        });

        let minHeight = 0;
        if (itemHeights.length === 1) {
          minHeight = itemHeights[0];
        } else if (itemHeights.length === 2) {
          minHeight = itemHeights[0] + itemHeights[1];
        } else {
          minHeight = itemHeights[0] + itemHeights[1] + itemHeights[2] * 0.5;
        }

        threadList.style.minHeight = `${minHeight}px`;
      }

      /**
       * Render the list of chat threads in the sidebar. Each entry is clickable
       * and optionally exposes a menu for renaming or deleting the thread.
       */
      function renderThreadList() {
        closeThreadMenu();
        threadList.innerHTML = '';
        const createLi = document.createElement('li');
        createLi.classList.add('new-thread-item');
        const createBtn = document.createElement('button');
        createBtn.type = 'button';
        createBtn.classList.add('new-thread-button');
        createBtn.appendChild(createIcon('icon-plus'));
        const createLabel = document.createElement('span');
        createLabel.classList.add('btn-label');
        createLabel.textContent = 'Start new chat';
        createBtn.appendChild(createLabel);
        createBtn.addEventListener('click', event => {
          event.stopPropagation();
          newThread();
        });
        createLi.appendChild(createBtn);
        threadList.appendChild(createLi);
        threads.forEach(thread => {
          const threadName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
          const li = document.createElement('li');
          li.dataset.id = thread.id;
          if (thread.id === currentThreadId) {
            li.classList.add('selected');
          }
          const nameSpan = document.createElement('span');
          nameSpan.classList.add('thread-name');
          nameSpan.textContent = threadName;
          li.appendChild(nameSpan);

          const menuBtn = document.createElement('button');
          menuBtn.type = 'button';
          menuBtn.classList.add('thread-menu-btn');
          menuBtn.setAttribute('aria-label', `Options for ${threadName}`);
          menuBtn.appendChild(createIcon('icon-more-vertical'));
          menuBtn.addEventListener('click', event => {
            event.stopPropagation();
            toggleThreadMenu(thread.id, menuBtn);
          });
          li.appendChild(menuBtn);

          li.addEventListener('click', () => selectThread(thread.id));
          threadList.appendChild(li);
        });

        updateThreadListMinHeight();
      }

      /**
       * Select a thread by ID, updating UI and state accordingly. If the
       * thread doesn't exist, the chat inputs are disabled.
       * @param {string} id thread identifier
       */
      function selectThread(id) {
        closeThreadMenu();
        currentThreadId = id;
        const thread = getThread(id);
        if (!thread) {
          updateChatAvailability();
          return;
        }
        // Populate title and system prompt
        threadTitleInput.value = thread.title || '';
        systemPromptInput.value = thread.systemPrompt || '';
        // Render messages
        renderMessages(thread);
        // Re-render thread list to highlight current
        renderThreadList();
        closeSidebar();
        updateChatAvailability();
      }

      /**
       * Create a new chat thread. This generates a unique id and inserts
       * an empty conversation into the list. The new thread becomes the
       * currently selected one.
       */
      function newThread() {
        const id = createThread();
        renderThreadList();
        selectThread(id);
      }

      /**
       * Delete a chat thread by id. After deletion the next available thread
       * becomes current. If none remain, the chat area is cleared and
       * disabled.
       * @param {string} targetId id to delete
       */
      function deleteThread(targetId = currentThreadId) {
        if (!targetId) return;
        const index = threads.findIndex(t => t.id === targetId);
        if (index === -1) return;
        const confirmed = window.confirm('Delete this chat thread?');
        if (!confirmed) return;
        threads.splice(index, 1);
        saveThreads();
        const ensuredId = ensureThreadExists();
        const firstThreadWithId = threads.find(thread => thread && typeof thread.id === 'string' && thread.id);
        currentThreadId = firstThreadWithId?.id || ensuredId || null;
        if (currentThreadId) {
          selectThread(currentThreadId);
          return;
        }
        threadTitleInput.value = '';
        systemPromptInput.value = '';
        messagesEl.innerHTML = '';
        renderThreadList();
        updateChatAvailability();
      }

      /**
       * Rename the given thread by prompting the user for a new title. The
       * current thread title input updates along with the list.
       * @param {string} threadId id of the thread to rename
       */
      function renameThread(threadId) {
        const thread = getThread(threadId);
        if (!thread) return;
        const currentName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
        const newName = window.prompt('Rename chat', currentName);
        if (newName === null) return;
        thread.title = newName.trim() || 'Untitled';
        saveThreads();
        renderThreadList();
        if (threadId === currentThreadId) {
          threadTitleInput.value = thread.title;
        }
      }

      function threadToMarkdown(thread) {
        if (!thread) return '';
        const title = typeof thread.title === 'string' && thread.title.trim() ? thread.title.trim() : 'Untitled chat';
        const lines = [`# ${title}`];
        const prompt = typeof thread.systemPrompt === 'string' ? thread.systemPrompt.trim() : '';
        if (prompt) {
          lines.push('', '## System Prompt', '', prompt);
        }
        const messages = Array.isArray(thread.messages) ? thread.messages : [];
        if (messages.length) {
          lines.push('', '## Messages', '');
          messages.forEach((message, index) => {
            const rawRole = typeof message?.role === 'string' ? message.role.trim() : '';
            const role = rawRole ? rawRole.charAt(0).toUpperCase() + rawRole.slice(1) : 'Message';
            let content = '';
            if (message && typeof message.content === 'string') {
              content = message.content;
            } else if (message && message.content != null) {
              try {
                content = JSON.stringify(message.content, null, 2);
              } catch (err) {
                content = String(message.content);
              }
            }
            if (!content.trim()) {
              content = '_No content_';
            }
            lines.push(`### ${index + 1}. ${role}`, '', content, '');
          });
        } else {
          lines.push('', '_No messages yet._');
        }
        return lines.join('\n');
      }

      function exportThreadMarkdown(threadId = currentThreadId) {
        if (!threadId) return;
        const thread = getThread(threadId);
        if (!thread) return;
        const markdown = threadToMarkdown(thread);
        const blob = new Blob([markdown], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const safeTitle = typeof thread.title === 'string' && thread.title.trim()
          ? thread.title.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')
          : 'chat';
        const filename = `${safeTitle || 'chat'}-${thread.id}.md`;
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Render all messages for a given thread. This simply loops over the
       * stored messages and creates elements for each role.
       * @param {object} thread chat thread
       */
      function renderMessages(thread) {
        messagesEl.innerHTML = '';
        thread.messages.forEach(msg => {
          const div = document.createElement('div');
          div.classList.add('message', msg.role);
          div.textContent = msg.content;
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      /**
       * Helper to append a message to the current thread, saving and re-rendering.
       * @param {string} role message role ('user', 'assistant', 'system')
       * @param {string} content message content
       */
      function addMessage(role, content) {
        const thread = updateThread(t => t.messages.push({ role, content }));
        if (thread) {
          renderMessages(thread);
        }
      }

      /**
       * Open the sidebar. Adds a class to the body that triggers the CSS
       * transform and disables page scrolling on mobile.
       */
      function openSidebar(arg) {
        let options = {};
        if (typeof Event !== 'undefined' && arg instanceof Event) {
          arg.preventDefault();
        } else if (arg && typeof arg === 'object') {
          options = arg;
        }
        document.body.classList.add('sidebar-open');
        closeThreadMenu();
        updateSidebarAria();
        const focusTarget = options.focusTarget;
        const skipDefaultFocus = Boolean(options.skipDefaultFocus || focusTarget);
        if (focusTarget && typeof focusTarget.focus === 'function') {
          setTimeout(() => {
            try {
              focusTarget.focus({ preventScroll: true });
            } catch (err) {
              focusTarget.focus();
            }
          }, 0);
        } else if (!skipDefaultFocus && closeSidebarBtn) {
          setTimeout(() => closeSidebarBtn.focus(), 0);
        }
      }

      /**
       * Close the sidebar and optionally restore focus to the hamburger button.
       * @param {object} options options.restoreFocus when true focuses the open button
       */
      function closeSidebar(options = {}) {
        const wasOpen = document.body.classList.contains('sidebar-open');
        if (wasOpen) {
          document.body.classList.remove('sidebar-open');
          if (options.restoreFocus && openSidebarBtn && !desktopMediaQuery.matches) {
            openSidebarBtn.focus({ preventScroll: true });
          }
        }
        updateSidebarAria();
      }

      function updateSidebarAria() {
        if (!sidebarEl) return;
        const hidden = !desktopMediaQuery.matches && !document.body.classList.contains('sidebar-open');
        sidebarEl.setAttribute('aria-hidden', hidden ? 'true' : 'false');
      }

      function guideToEndpointSetup() {
        openSidebar({ focusTarget: endpointSelect, skipDefaultFocus: true });
        if (!endpointSelect) {
          return;
        }
        const highlightClass = 'highlight-pulse';
        const cleanupHighlight = () => endpointSelect.classList.remove(highlightClass);
        endpointSelect.addEventListener('blur', cleanupHighlight, { once: true });
        window.requestAnimationFrame(() => {
          try {
            endpointSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
          } catch (err) {
            // Ignore scroll errors.
          }
          endpointSelect.classList.add(highlightClass);
          window.setTimeout(cleanupHighlight, 1800);
          try {
            if (typeof endpointSelect.showPicker === 'function') {
              endpointSelect.showPicker();
            } else {
              endpointSelect.focus({ preventScroll: true });
            }
          } catch (err) {
            try {
              endpointSelect.focus({ preventScroll: true });
            } catch (focusErr) {
              endpointSelect.focus();
            }
          }
        });
      }

      function updateAuthGuidance() {
        if (!authGuidance) {
          return;
        }
        if (consecutiveAuthErrors >= 2) {
          authGuidance.classList.add('active');
          authGuidance.hidden = false;
          authGuidance.setAttribute('aria-hidden', 'false');
        } else {
          authGuidance.classList.remove('active');
          authGuidance.hidden = true;
          authGuidance.setAttribute('aria-hidden', 'true');
        }
      }

      /**
       * Close the thread action menu if open.
       */
      function closeThreadMenu() {
        if (!openThreadMenu) return;
        document.removeEventListener('mousedown', openThreadMenu.outsideHandler);
        document.removeEventListener('keydown', openThreadMenu.keyHandler);
        if (openThreadMenu.menuEl.parentNode) {
          openThreadMenu.menuEl.parentNode.removeChild(openThreadMenu.menuEl);
        }
        openThreadMenu = null;
      }

      /**
       * Toggle the thread action menu for a given thread. The menu appears
       * anchored to the provided element and is removed when clicking outside
       * or pressing escape.
       * @param {string} threadId id of the thread
       * @param {HTMLElement} anchor element to anchor the menu to
       */
      function toggleThreadMenu(threadId, anchor) {
        if (openThreadMenu && openThreadMenu.anchor === anchor) {
          closeThreadMenu();
          return;
        }
        closeThreadMenu();
        const menu = document.createElement('div');
        menu.classList.add('thread-menu');

        const renameBtn = document.createElement('button');
        renameBtn.type = 'button';
        renameBtn.appendChild(createIcon('icon-edit'));
        const renameLabel = document.createElement('span');
        renameLabel.classList.add('btn-label');
        renameLabel.textContent = 'Rename';
        renameBtn.appendChild(renameLabel);
        renameBtn.addEventListener('click', () => {
          closeThreadMenu();
          renameThread(threadId);
        });
        menu.appendChild(renameBtn);

        const exportThreadBtn = document.createElement('button');
        exportThreadBtn.type = 'button';
        exportThreadBtn.appendChild(createIcon('icon-export'));
        const exportLabel = document.createElement('span');
        exportLabel.classList.add('btn-label');
        exportLabel.textContent = 'Export (.md)';
        exportThreadBtn.appendChild(exportLabel);
        exportThreadBtn.addEventListener('click', () => {
          closeThreadMenu();
          exportThreadMarkdown(threadId);
        });
        menu.appendChild(exportThreadBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.appendChild(createIcon('icon-trash'));
        const deleteLabel = document.createElement('span');
        deleteLabel.classList.add('btn-label');
        deleteLabel.textContent = 'Delete';
        deleteBtn.appendChild(deleteLabel);
        deleteBtn.classList.add('delete');
        deleteBtn.addEventListener('click', () => {
          closeThreadMenu();
          deleteThread(threadId);
        });
        menu.appendChild(deleteBtn);

        const copyLinkBtn = document.createElement('button');
        copyLinkBtn.type = 'button';
        copyLinkBtn.appendChild(createIcon('icon-link'));
        const copyLabel = document.createElement('span');
        copyLabel.classList.add('btn-label');
        copyLabel.textContent = 'Copy link with current title/system/prompt';
        copyLinkBtn.appendChild(copyLabel);
        copyLinkBtn.addEventListener('click', async () => {
          const url = buildPreloadUrl();
          try {
            await navigator.clipboard.writeText(url);
            showToast('Link copied to clipboard');
          } catch (err) {
            window.prompt('Copy this link:', url);
          } finally {
            closeThreadMenu();
          }
        });
        menu.appendChild(copyLinkBtn);

        document.body.appendChild(menu);
        const rect = anchor.getBoundingClientRect();
        menu.style.top = `${window.scrollY + rect.bottom + 4}px`;
        menu.style.left = `${window.scrollX + rect.left}px`;
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = document.documentElement.clientWidth;
        if (menuRect.right > viewportWidth) {
          const adjustedLeft = Math.max(8, viewportWidth - menuRect.width - 8);
          menu.style.left = `${window.scrollX + adjustedLeft}px`;
        }

        const outsideHandler = event => {
          if (menu.contains(event.target) || anchor.contains(event.target)) {
            return;
          }
          closeThreadMenu();
        };
        const keyHandler = event => {
          if (event.key === 'Escape') {
            closeThreadMenu();
          }
        };
        document.addEventListener('mousedown', outsideHandler);
        document.addEventListener('keydown', keyHandler);
        openThreadMenu = {
          menuEl: menu,
          anchor,
          outsideHandler,
          keyHandler
        };
      }

      /**
       * Send the current message to the API. This prevents default form
       * submission behaviour, validates chat readiness and content, then
       * appends the user message, sends the request and appends the reply.
       * It also shows a loading indicator while the API call is in flight.
       * @param {Event} event form submit event
       */
      async function handleSendMessage(event) {
        event.preventDefault();
        const state = getChatState();
        if (!state.ready) {
          if (!state.hasEndpoint) {
            triggerEndpointGuidance();
          }
          updateChatAvailability();
          return;
        }
        const message = messageInput.value.trim();
        if (!message) {
          updateSendButtonDisabled(state.ready);
          return;
        }
        addMessage('user', message);
        messageInput.value = '';
        updateSendButtonDisabled(state.ready);

        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.classList.add('loading');
        messagesEl.appendChild(loadingIndicator);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          const reply = await sendToApi();
          consecutiveAuthErrors = 0;
          updateAuthGuidance();
          addMessage('assistant', reply);
        } catch (err) {
          console.error(err);
          addMessage('system', 'Error: ' + err.message);
          if (err && (err.isAuthError || err.status === 401 || err.status === 403)) {
            consecutiveAuthErrors = Math.min(consecutiveAuthErrors + 1, 3);
          } else {
            consecutiveAuthErrors = 0;
          }
          updateAuthGuidance();
        } finally {
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }
        }
      }

      /**
       * Send the conversation to the configured API endpoint. Uses the current
       * model and thread messages. Throws if required fields are missing or
       * the response status is not ok.
       */
      async function sendToApi() {
        if (!config.endpoint) {
          throw new Error('Endpoint is not configured.');
        }
        const thread = currentThread();
        if (!thread) {
          throw new Error('No thread selected.');
        }
        if (!config.model) {
          throw new Error('Model is not selected.');
        }
        const systemPrompt = thread.systemPrompt?.trim();
        const messagesForRequest = systemPrompt
          ? [{ role: 'system', content: systemPrompt }, ...thread.messages]
          : [...thread.messages];
        // Compose request payload. Adjust this object to match the API expected schema.
        const body = {
          model: config.model,
          messages: messagesForRequest
        };
        const headers = {
          'Content-Type': 'application/json'
        };
        // Include authorization header if token is provided
        if (config.token) {
          headers['Authorization'] = `Bearer ${config.token}`;
        }
        let chatEndpoint;
        try {
          chatEndpoint = deriveChatCompletionsUrl(config.endpoint);
        } catch (err) {
          throw new Error('Invalid endpoint: ' + err.message);
        }

        const response = await fetch(chatEndpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify(body)
        });
        if (!response.ok) {
          const error = new Error('API responded with status ' + response.status);
          error.status = response.status;
          if (response.status === 401 || response.status === 403) {
            error.isAuthError = true;
          }
          throw error;
        }
        // Parse JSON response. We expect a property `choices[0].message.content` similar to OpenAI.
        const data = await response.json();
        const choice = Array.isArray(data?.choices) && data.choices.length ? data.choices[0] : null;
        const reply = choice?.message?.content || choice?.text || (typeof data?.answer === 'string' ? data.answer : '');
        return reply || JSON.stringify(data);
      }

      /**
       * Given an endpoint (possibly relative) derive the URL for the models
       * endpoint. This attempts to find the nearest version segment and
       * replace the trailing path with 'models'.
       * @param {string} endpoint base endpoint
       */
      function deriveModelsUrl(endpoint) {
        let url;
        try {
          url = new URL(endpoint);
        } catch (err) {
          url = new URL(endpoint, window.location.href);
        }
        const segments = url.pathname.split('/').filter(Boolean);
        if (segments[segments.length - 1] === 'models') {
          url.search = '';
          url.hash = '';
          return url.toString();
        }

        let versionIndex = -1;
        for (let i = segments.length - 1; i >= 0; i--) {
          if (/^v\d+$/i.test(segments[i])) {
            versionIndex = i;
            break;
          }
        }
        const baseSegments = versionIndex !== -1 ? segments.slice(0, versionIndex + 1) : segments;
        url.pathname = '/' + [...baseSegments, 'models'].join('/');
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      /**
       * Given a base endpoint derive the chat completions URL. This appends a
       * single `/chat/completions` segment to the path while preserving other
       * segments and stripping query/hash components.
       * @param {string} endpoint base endpoint
       */
      function deriveChatCompletionsUrl(endpoint) {
        let url;
        try {
          url = new URL(endpoint);
        } catch (err) {
          url = new URL(endpoint, window.location.href);
        }
        const segments = url.pathname.split('/').filter(Boolean);
        const alreadySuffixed =
          segments.length >= 2 &&
          segments[segments.length - 2] === 'chat' &&
          segments[segments.length - 1] === 'completions';
        if (alreadySuffixed) {
          url.search = '';
          url.hash = '';
          return url.toString();
        }
        const cleanedSegments = [];
        for (let i = 0; i < segments.length; i += 1) {
          if (segments[i] === 'chat' && segments[i + 1] === 'completions') {
            i += 1;
            continue;
          }
          cleanedSegments.push(segments[i]);
        }
        cleanedSegments.push('chat', 'completions');
        url.pathname = '/' + cleanedSegments.join('/');
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      /**
       * Fetch the list of available models for the current endpoint and token.
       * Updates the dropdown with the returned ids. Silent mode suppresses
       * alerts for invalid endpoints or no models returned.
       * @param {object} opts silent: when true suppresses alert messages
       */
      async function refreshModels({ silent } = {}) {
        const endpoint = endpointInput.value.trim() || config.endpoint;
        if (!endpoint) {
          if (!silent) {
            alert('Set an endpoint before refreshing models.');
          }
          updateChatAvailability();
          return;
        }
        let modelsEndpoint;
        try {
          modelsEndpoint = deriveModelsUrl(endpoint);
        } catch (err) {
          console.error('Invalid endpoint:', err);
          if (!silent) {
            alert('Invalid endpoint: ' + err.message);
          }
          updateChatAvailability();
          return;
        }

        if (config.endpoint !== endpoint) {
          config.endpoint = endpoint;
          persistConfig();
        }

        refreshModelsBtn.disabled = true;
        const refreshLabelTarget = refreshModelsBtn.querySelector('.btn-label');
        const originalLabel = refreshLabelTarget ? refreshLabelTarget.textContent : refreshModelsBtn.textContent;
        if (refreshLabelTarget) {
          refreshLabelTarget.textContent = 'Loading...';
        } else {
          refreshModelsBtn.textContent = 'Loading...';
        }
        try {
          const headers = { Accept: 'application/json' };
          const token = tokenInput.value.trim() || config.token;
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
            if (config.token !== token) {
              config.token = token;
              persistConfig();
            }
          }
          const response = await fetch(modelsEndpoint, { method: 'GET', headers });
          if (!response.ok) {
            throw new Error('Status ' + response.status);
          }
          const data = await response.json();
          const rawList = Array.isArray(data?.data)
            ? data.data
            : Array.isArray(data?.models)
              ? data.models
              : [];
          const ids = rawList
            .map(item => {
              if (typeof item === 'string') return item.trim();
              if (item && typeof item.id === 'string') return item.id.trim();
              if (item && typeof item.name === 'string') return item.name.trim();
              return '';
            })
            .filter(id => id.length > 0);
          if (!ids.length) {
            throw new Error('No models returned.');
          }
          storeModels(ids);
          renderModelOptions(models, config.model);
          if (!silent) {
            alert('Models updated.');
          }
        } catch (err) {
          console.error('Failed to refresh models:', err);
          if (!silent) {
            alert('Failed to load models: ' + err.message);
          }
        } finally {
          refreshModelsBtn.disabled = false;
          if (refreshLabelTarget) {
            refreshLabelTarget.textContent = originalLabel;
          } else {
            refreshModelsBtn.textContent = originalLabel;
          }
          updateChatAvailability();
        }
      }

      /**
       * Export chat history to a JSON file. The user can download their
       * threads array as a structured JSON document.
       */
      function exportHistory() {
        const dataStr = JSON.stringify(threads, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-history.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Import chat history from a selected JSON file. The file is parsed
       * and, if valid, replaces the current threads list. Afterwards the
       * first thread is selected or the chat area is disabled if none.
       * @param {Event} event input change event
       */
      function importHistory(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imported = JSON.parse(e.target.result);
            if (Array.isArray(imported)) {
              threads = imported;
              saveThreads();
              const ensuredId = ensureThreadExists();
              renderThreadList();
              const firstThreadWithId = threads.find(thread => thread && typeof thread.id === 'string' && thread.id);
              const nextId = firstThreadWithId?.id || ensuredId || null;
              if (nextId) {
                selectThread(nextId);
              } else {
                currentThreadId = null;
                updateChatAvailability();
              }
              alert('Import successful');
            } else {
              alert('Invalid file format.');
            }
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
          // Reset input to allow re-importing same file later
          importInput.value = '';
        };
        reader.readAsText(file);
      }

      /**
       * Export the current config and model list to a JSON file. Includes
       * an exportedAt timestamp for reference.
       */
      function exportConfig() {
        const payload = {
          config: { ...config },
          models: [...models],
          exportedAt: new Date().toISOString()
        };
        const dataStr = JSON.stringify(payload, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-config.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function normalizeConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        return {
          endpoint: typeof raw.endpoint === 'string' ? raw.endpoint : '',
          token: typeof raw.token === 'string' ? raw.token : '',
          model: typeof raw.model === 'string' ? raw.model : ''
        };
      }

      function buildConfigShareUrl() {
        const trimmed = {
          endpoint: (config.endpoint || '').trim(),
          token: (config.token || '').trim(),
          model: (config.model || '').trim()
        };
        const hasValue = Object.values(trimmed).some(value => value);
        if (!hasValue) {
          return '';
        }
        const base = new URL(window.location.href);
        base.hash = '';
        base.search = '';
        const payload = base64UrlEncode(JSON.stringify(trimmed));
        base.searchParams.set('settings', payload);
        return base.toString();
      }

      function openConfigQr() {
        if (!configQrModal || !configQrCode || !shareConfigBtn) {
          return;
        }
        const shareUrl = buildConfigShareUrl();
        if (!shareUrl) {
          showToast('Configure an endpoint, token, or model before sharing.');
          return;
        }
        ensureQrLibrary();
        configQrCode.innerHTML = '';
        new QRCode(configQrCode, {
          text: shareUrl,
          width: 256,
          height: 256,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.H
        });
        configQrCode.setAttribute('aria-label', 'QR code for shared chat settings');
        if (configQrLink) {
          configQrLink.href = shareUrl;
          configQrLink.textContent = shareUrl;
        }
        latestConfigShareUrl = shareUrl;
        openModal(configQrModal, { focusEl: configQrCloseBtn, triggerEl: shareConfigBtn });
      }

      function closeConfigQr({ returnFocus = true } = {}) {
        if (!configQrModal) return;
        if (activeModal === configQrModal) {
          closeModal({ returnFocus });
        } else if (!configQrModal.hidden) {
          configQrModal.hidden = true;
          if (returnFocus && shareConfigBtn) {
            shareConfigBtn.focus();
          }
        }
      }

      async function copyConfigShareLink() {
        if (!latestConfigShareUrl) {
          latestConfigShareUrl = buildConfigShareUrl();
          if (!latestConfigShareUrl) {
            showToast('Nothing to copy yet. Generate a share link first.');
            return;
          }
        }
        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(latestConfigShareUrl);
          } else {
            throw new Error('Clipboard API unavailable');
          }
          showToast('Share link copied to clipboard.');
        } catch (err) {
          const textarea = document.createElement('textarea');
          textarea.value = latestConfigShareUrl;
          textarea.setAttribute('readonly', '');
          textarea.style.position = 'absolute';
          textarea.style.left = '-9999px';
          document.body.appendChild(textarea);
          textarea.select();
          let copied = false;
          try {
            copied = document.execCommand('copy');
          } catch (copyErr) {
            copied = false;
          }
          document.body.removeChild(textarea);
          if (copied) {
            showToast('Share link copied to clipboard.');
          } else {
            window.prompt('Copy this link:', latestConfigShareUrl);
          }
        }
      }

      /**
       * Import a configuration file. Extracts config and model list and
       * updates session storage accordingly. Will override current session
       * config but not modify saved threads.
       * @param {Event} event input change event
       */
      function importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imported = JSON.parse(e.target.result);
            const source = imported && typeof imported === 'object'
              ? (imported.config && typeof imported.config === 'object' ? imported.config : imported)
              : null;
            const nextConfig = normalizeConfig(source);
            if (!nextConfig) {
              alert('Invalid config file.');
              return;
            }
            config = { ...defaults, ...nextConfig };
            persistConfig();
            endpointInput.value = config.endpoint;
            tokenInput.value = config.token;
            syncEndpointControls(config.endpoint);
            consecutiveAuthErrors = 0;
            updateAuthGuidance();
            if (Array.isArray(imported?.models)) {
              storeModels(imported.models);
            }
            renderModelOptions(models, config.model);
            alert('Configuration imported.');
          } catch (err) {
            alert('Failed to import config: ' + err.message);
          }
          importConfigInput.value = '';
        };
        reader.readAsText(file);
      }

      async function applyConfigFromUrl() {
        const params = new URLSearchParams(window.location.search);
        if (!params.has('settings') && !params.has('endpoint') && !params.has('token') && !params.has('model')) {
          return;
        }
        let merged = {};
        const encodedSettings = params.get('settings');
        if (encodedSettings) {
          try {
            const decoded = base64UrlDecode(encodedSettings);
            const parsed = JSON.parse(decoded);
            if (parsed && typeof parsed === 'object') {
              merged = { ...merged, ...parsed };
            }
          } catch (err) {
            console.warn('Ignoring invalid settings parameter:', err);
          }
        }
        ['endpoint', 'token', 'model'].forEach(key => {
          if (params.has(key)) {
            merged[key] = params.get(key) ?? '';
          }
        });
        const nextConfig = normalizeConfig(merged);
        if (!nextConfig) {
          return;
        }
        const previous = { ...config };
        const desiredModel = (nextConfig.model || '').trim();
        const endpointChanged = typeof nextConfig.endpoint === 'string' && nextConfig.endpoint !== previous.endpoint;
        const tokenChanged = typeof nextConfig.token === 'string' && nextConfig.token !== previous.token;
        config = { ...defaults, ...config, ...nextConfig };
        persistConfig();
        endpointInput.value = config.endpoint;
        tokenInput.value = config.token;
        syncEndpointControls(config.endpoint);
        consecutiveAuthErrors = 0;
        updateAuthGuidance();
        const needsModelRefresh =
          !!config.endpoint &&
          (endpointChanged || tokenChanged || (desiredModel && !models.includes(desiredModel)));
        if (needsModelRefresh) {
          await refreshModels({ silent: true });
        }
        renderModelOptions(models, config.model);
        const appliedModel = config.model;
        const changed =
          previous.endpoint !== config.endpoint ||
          previous.token !== config.token ||
          previous.model !== config.model;
        const warningMessage = desiredModel && appliedModel !== desiredModel
          ? `Requested model "${desiredModel}" is not available at this endpoint.` +
            (appliedModel ? ` Using "${appliedModel}" instead.` : ' No models are currently available.')
          : '';
        if (warningMessage) {
          console.warn(warningMessage);
        }
        updateChatAvailability();
        if (changed || warningMessage) {
          const toastMessage = warningMessage
            ? (changed ? `Settings imported from shared link. ${warningMessage}` : warningMessage)
            : 'Settings imported from shared link.';
          showToast(toastMessage);
        }
        try {
          const cleanedUrl = new URL(window.location.href);
          ['settings', 'endpoint', 'token', 'model'].forEach(key => cleanedUrl.searchParams.delete(key));
          history.replaceState(null, document.title, cleanedUrl.toString());
        } catch (err) {
          console.warn('Unable to clear shared settings parameters:', err);
        }
      }

      /**
       * Parse the current URL's query parameters and, if any chat data is
       * provided, prepopulate a new chat thread. Supported parameters:
       *
       *   - title: the chat title
       *   - system: the system prompt
       *   - prompt: the initial message to prefill in the message input
       *
       * If at least one of these parameters is present, a new thread is
       * created (without altering existing ones) and selected. The chat
       * remains disabled until the user configures an endpoint and model.
       */
      function parseUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const titleParam = params.get('title') || params.get('chat') || params.get('name');
        const systemParam = params.get('system') || params.get('systemPrompt') || params.get('system_prompt');
        const promptParam = params.get('prompt') || params.get('message') || params.get('msg');
        // Only act if at least one parameter is present and no threads yet created via params
        if (titleParam || systemParam || promptParam) {
          // Create a new thread with provided values
          const threadDetails = {
            title: titleParam ? decodeURIComponent(titleParam) : 'New chat',
            systemPrompt: systemParam ? decodeURIComponent(systemParam) : ''
          };
          const id = createThread(threadDetails);
          currentThreadId = id;
          const threadObj = getThread(id);
          // Insert into UI
          renderThreadList();
          selectThread(id);
          // Overwrite fields with decoded values
          threadTitleInput.value = threadObj?.title ?? threadDetails.title;
          systemPromptInput.value = threadObj?.systemPrompt ?? threadDetails.systemPrompt;
          if (promptParam) {
            messageInput.value = decodeURIComponent(promptParam);
          }
          updateChatAvailability();
        }
      }

      /**
       * Initialize the application. Loads persisted models, config and threads
       * from storage, handles URL-based prepopulation, renders the thread
       * list and selects the first available thread. Also refreshes models
       * silently if an endpoint is provided without cached models.
       */
      async function init() {
        populateEndpointSelect();
        loadModels();
        loadConfig();
        await applyConfigFromUrl();
        loadThreads();
        // Check if URL contains chat data and create a thread accordingly
        parseUrlParams();
        const ensuredId = ensureThreadExists();
        renderThreadList();
        // If a thread was created via URL params select it; otherwise pick the first existing
        const firstThreadWithId = threads.find(thread => thread && typeof thread.id === 'string' && thread.id);
        const targetThreadId = currentThreadId || ensuredId || firstThreadWithId?.id || null;
        if (targetThreadId) {
          selectThread(targetThreadId);
        } else {
          updateChatAvailability();
        }
        if (!models.length && config.endpoint) {
          refreshModels({ silent: true });
        }
      }
      init().catch(err => {
        console.error('Failed to initialize application:', err);
      });
      updateAuthGuidance();

      // Attach event listeners
      if (endpointSelect) {
        endpointSelect.addEventListener('change', () => {
          applyEndpointOption(endpointSelect.value);
        });
      }
      if (endpointInput) {
        endpointInput.addEventListener('input', () => {
          syncEndpointControls(endpointInput.value.trim());
        });
        endpointInput.addEventListener('change', () => {
          persistEndpointValue(endpointInput.value, { refresh: true });
        });
      }
      if (tokenInput) {
        tokenInput.addEventListener('change', () => {
          persistTokenValue(tokenInput.value, { refresh: true });
        });
      }
      refreshModelsBtn.addEventListener('click', () => refreshModels());
      modelSelect.addEventListener('change', () => {
        config.model = modelSelect.value;
        persistConfig();
        updateChatAvailability();
      });
      messageForm.addEventListener('submit', handleSendMessage);
      messageInput.addEventListener('input', () => {
        updateSendButtonDisabled(getChatState().ready);
      });
      if (messageInputOverlay) {
        messageInputOverlay.addEventListener('click', () => {
          if (!messageInput || !messageInput.disabled) {
            return;
          }
          const state = getChatState();
          if (!state.hasEndpoint) {
            triggerEndpointGuidance();
          }
        });
      }
      if (toast) {
        toast.addEventListener('click', hideToast);
      }
      exportBtn.addEventListener('click', exportHistory);
      importBtn.addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', importHistory);
      exportConfigBtn.addEventListener('click', exportConfig);
      importConfigBtn.addEventListener('click', () => importConfigInput.click());
      importConfigInput.addEventListener('change', importConfig);
      if (shareConfigBtn) {
        shareConfigBtn.addEventListener('click', openConfigQr);
      }
      if (configQrCloseBtn) {
        configQrCloseBtn.addEventListener('click', () => closeConfigQr());
      }
      if (copyConfigLinkBtn) {
        copyConfigLinkBtn.addEventListener('click', copyConfigShareLink);
      }
      if (importSettingsShortcut) {
        importSettingsShortcut.addEventListener('click', event => {
          event.preventDefault();
          if (importConfigInput) {
            importConfigInput.click();
          }
        });
      }
      if (authGuideEndpointBtn) {
        authGuideEndpointBtn.addEventListener('click', event => {
          event.preventDefault();
          guideToEndpointSetup();
        });
      }
      if (authGuideImportBtn) {
        authGuideImportBtn.addEventListener('click', event => {
          event.preventDefault();
          if (importConfigInput) {
            importConfigInput.click();
          }
        });
      }
      if (aboutBtn) {
        aboutBtn.addEventListener('click', openAbout);
      }
      if (aboutCloseBtn) {
        aboutCloseBtn.addEventListener('click', closeAbout);
      }
      if (modalBackdrop) {
        modalBackdrop.addEventListener('click', () => {
          if (activeModal === configQrModal) {
            closeConfigQr();
          } else if (activeModal === aboutModal) {
            closeAbout();
          }
        });
      }
      window.addEventListener('resize', updateThreadListMinHeight);
      if (dismissPromoBtn) {
        dismissPromoBtn.addEventListener('click', () => {
          sessionStorage.setItem('promoDismissed', '1');
          maybeShowPromo();
        });
      }
      if (downloadPageBtn) {
        downloadPageBtn.addEventListener('click', () => {
          try {
            const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'private-chat.html';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } catch (err) {
            alert('If download is blocked by your browser, use “Save Page As…” instead.');
          }
        });
      }
      if (openSidebarBtn) {
        openSidebarBtn.addEventListener('click', openSidebar);
      }
      if (closeSidebarBtn) {
        closeSidebarBtn.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape') {
          if (activeModal === configQrModal) {
            closeConfigQr();
            return;
          }
          if (activeModal === aboutModal) {
            closeAbout();
            return;
          }
          if (document.body.classList.contains('sidebar-open')) {
            closeSidebar({ restoreFocus: true });
            return;
          }
          closeThreadMenu();
        }
      });
      const handleViewportChange = event => {
        if (event.matches) {
          closeSidebar();
        }
        updateSidebarAria();
      };
      if (desktopMediaQuery.addEventListener) {
        desktopMediaQuery.addEventListener('change', handleViewportChange);
      } else if (desktopMediaQuery.addListener) {
        desktopMediaQuery.addListener(handleViewportChange);
      }
      updateSidebarAria();

      threadTitleInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.title = threadTitleInput.value.trim() || 'Untitled';
          renderThreadList();
        });
      });
      systemPromptInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.systemPrompt = systemPromptInput.value.trim();
        });
      });
      initMarketing();
    })();
  </script>
</body>
</html>
