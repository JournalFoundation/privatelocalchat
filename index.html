<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Private Local Chat</title>
  <style>
    /* Minimal styling for the chat client UI. */

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #fff;
      color: #222;
      min-height: 100vh;
    }

    #app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Sidebar styling */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(85vw, 320px);
      background: #f4f4f4;
      border-right: 1px solid #ddd;
      box-shadow: 2px 0 12px rgba(0, 0, 0, 0.15);
      padding: 16px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.25s ease;
      z-index: 1001;
    }

    body.sidebar-open .sidebar {
      transform: translateX(0);
    }

    body.sidebar-open {
      overflow: hidden;
    }

    .sidebar h2,
    .sidebar h3 {
      margin-top: 0;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      gap: 8px;
    }

    .sidebar-close {
      border: none;
      background: transparent;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 1;
      padding: 4px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #333;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .hint-text {
      margin-top: -4px;
      margin-bottom: 12px;
      font-size: 0.85rem;
      line-height: 1.4;
      color: #555;
    }

    .hint-text a {
      color: inherit;
      text-decoration: underline;
    }

    .link-btn {
      border: none;
      background: transparent;
      color: #007bff;
      padding: 0;
      font: inherit;
      text-decoration: underline;
      cursor: pointer;
    }

    .link-btn:hover {
      color: #0056b3;
    }

    .link-btn:focus-visible {
      outline: 2px solid #0056b3;
      outline-offset: 2px;
    }

    .form-group button {
      width: 100%;
      padding: 8px;
      background: #007bff;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .form-group button:hover {
      background: #0056b3;
    }

    .threads-header {
      margin-top: 16px;
    }

    .threads-header h3 {
      margin: 0 0 12px 0;
    }

    .thread-list {
      list-style: none;
      padding: 0;
      margin: 0;
      flex: 1;
      overflow-y: auto;
    }

    .thread-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 4px;
    }

    .thread-list li.selected {
      background: #007bff;
      color: #fff;
    }

    .thread-list li:hover {
      background: #e2e6ea;
    }

    .thread-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .thread-menu-btn {
      border: none;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px 4px;
    }

    .thread-menu-btn:hover {
      color: #007bff;
    }

    .thread-list li.selected .thread-menu-btn:hover {
      color: #cfe2ff;
    }

    .thread-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      padding: 4px 0;
      min-width: 140px;
      z-index: 1101;
    }

    .thread-menu button {
      width: 100%;
      background: none;
      border: none;
      text-align: left;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .thread-menu button:hover {
      background: #f0f0f0;
    }

    .thread-menu button.delete {
      color: #c1121f;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px;
      font-size: 0.9rem;
      color: #333;
    }

    .action-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .action-label {
      font-weight: 600;
    }

    .icon-btn {
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 4px;
      padding: 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease;
      color: #333;
    }

    .icon-btn:hover {
      background: #e2e6ea;
      border-color: #b3b3b3;
    }

    .icon-btn:focus {
      outline: 2px solid #0056b3;
      outline-offset: 2px;
    }

    .icon-btn svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .highlight-pulse {
      box-shadow: 0 0 0 4px rgba(0, 123, 255, 0.35);
      border-radius: 4px;
      transition: box-shadow 0.25s ease;
    }

    .thread-list li.new-thread-item {
      display: block;
      padding: 0;
      background: none;
      margin-bottom: 8px;
    }

    .thread-list li.new-thread-item:hover {
      background: none;
    }

    .new-thread-button {
      width: 100%;
      border: none;
      background: #28a745;
      color: #fff;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .new-thread-button:hover {
      background: #1c7e32;
    }

    .model-select-row button {
      width: 100%;
      padding: 8px;
      font-size: 0.9rem;
    }

    .model-select-row button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .model-select-row select {
      width: 100%;
      margin-top: 8px;
    }

    /* Chat area styling */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-bottom: 1px solid #ddd;
    }

    .thread-title {
      flex: 1;
      font-size: 1.1rem;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    /* === Promo banner (minimal, mobile-first) === */
    .promo-banner {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 12px;
      background: #fff8e1;
      border-bottom: 1px solid #f0c36d;
      color: #7a5200;
      font-size: 0.9rem;
    }

    .promo-banner[hidden] {
      display: none;
    }

    .promo-banner a {
      color: #7a5200;
      text-decoration: underline;
    }

    .promo-banner .dismiss {
      border: none;
      background: transparent;
      font-size: 1.2rem;
      line-height: 1;
      cursor: pointer;
      color: #7a5200;
    }

    /* Info button in header */
    .about-btn {
      width: 44px;
      height: 44px;
      border: 2px solid #007bff;
      border-radius: 50%;
      background: #fff;
      color: #007bff;
      font-weight: 700;
      font-size: 1.25rem;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      cursor: pointer;
    }

    .about-btn:focus-visible {
      outline: 3px solid #80bdff;
      outline-offset: 2px;
    }

    /* === Bottom-sheet modal === */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1000;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1001;
    }

    .modal[hidden],
    .modal-backdrop[hidden] {
      display: none !important;
    }

    .modal .sheet {
      width: 100%;
      max-height: 85vh;
      overflow: auto;
      background: #fff;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      box-shadow: 0 -6px 24px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    .modal .modal-close {
      position: absolute;
      right: 16px;
      top: 12px;
      border: none;
      background: transparent;
      font-size: 1.6rem;
      cursor: pointer;
    }

    .modal h2 {
      margin-top: 4px;
    }

    .modal .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 12px 0;
    }

    .modal .cta-link {
      display: inline-block;
      padding: 8px 10px;
      border-radius: 6px;
      background: #f1f3f5;
      color: #0a58ca;
      text-decoration: none;
    }

    .modal .primary,
    .modal .secondary {
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #ccc;
      cursor: pointer;
      background: #fff;
    }

    .modal .primary {
      background: #0d6efd;
      color: #fff;
      border-color: #0d6efd;
    }

    .modal .secondary {
      background: #fff;
      color: #0d6efd;
      border-color: #0d6efd;
    }

    .modal .fine-print {
      color: #666;
      font-size: 0.85rem;
    }

    /* Desktop: center the dialog instead of bottom sheet */
    @media (min-width: 900px) {
      .modal {
        align-items: center;
      }

      .modal .sheet {
        max-width: 720px;
        border-radius: 12px;
        padding: 20px 24px;
      }
    }

    .system-prompt-container {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }

    .system-prompt-container label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #555;
    }

    .system-prompt-container textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .messages {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      background: #fafafa;
    }

    .message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user {
      background: #e9f7ef;
      align-self: flex-end;
    }

    .message.assistant {
      background: #f1f1f1;
      align-self: flex-start;
    }

    .message.system {
      background: #fffbe6;
      border: 1px dashed #ccc;
    }

    .message-form {
      display: flex;
      padding: 12px;
      border-top: 1px solid #ddd;
      background: #f8f9fa;
    }

    .message-form textarea {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      font-size: 0.9rem;
      min-height: 60px;
    }

    .message-form button {
      margin-left: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .message-form button:hover {
      background: #0056b3;
    }

    .message-form button:disabled {
      background: #94b9e8;
      cursor: not-allowed;
    }

    .message-form textarea:disabled {
      background: #e9ecef;
      cursor: not-allowed;
    }

    .message-form.disabled {
      opacity: 0.7;
    }

    .message-input-wrapper {
      position: relative;
      flex: 1;
      display: flex;
    }

    .message-input-wrapper textarea {
      flex: 1;
      width: 100%;
    }

    .message-input-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .message-form.disabled .message-input-overlay {
      pointer-events: auto;
      cursor: not-allowed;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 24px;
      transform: translate(-50%, 100%);
      background: rgba(34, 34, 34, 0.92);
      color: #fff;
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 0.9rem;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
      opacity: 0;
      transition: opacity 0.18s ease, transform 0.18s ease;
      z-index: 2000;
      max-width: min(90vw, 320px);
      text-align: center;
    }

    .toast.visible {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    @media (prefers-reduced-motion: reduce) {
      .toast {
        transition: none;
      }
    }

    .chat-notice {
      display: none;
      padding: 12px;
      background: #fff3cd;
      border-bottom: 1px solid #f7d070;
      color: #6c4a00;
      font-size: 0.9rem;
    }

    .chat-notice.active {
      display: block;
    }

    .chat-notice.requires-endpoint {
      cursor: pointer;
    }

    .chat-notice.requires-endpoint:focus-visible {
      outline: 2px solid #f7d070;
      outline-offset: 2px;
    }

    .chat-notice ul {
      margin: 0;
      padding-left: 20px;
    }

    .chat-notice p {
      margin: 0 0 8px;
    }

    .notice-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .notice-actions button {
      border: none;
      border-radius: 4px;
      padding: 6px 12px;
      font-size: 0.85rem;
      cursor: pointer;
      background: #007bff;
      color: #fff;
    }

    .notice-actions button.secondary {
      background: #6c757d;
    }

    .notice-actions button:focus-visible {
      outline: 2px solid #fff;
      outline-offset: 2px;
    }

    /* Loading indicator styling */
    .loading {
      display: inline-block;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #007bff;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    .mobile-toggle {
      border: none;
      background: transparent;
      font-size: 1.6rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px 6px;
      color: #007bff;
    }

    .mobile-toggle:focus,
    .sidebar-close:focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }

    #sidebarOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 1000;
    }

    body.sidebar-open #sidebarOverlay {
      opacity: 1;
      pointer-events: auto;
    }

    @media (min-width: 900px) {
      #app {
        flex-direction: row;
        min-height: 100vh;
      }

      .sidebar {
        position: relative;
        transform: none;
        width: 300px;
        max-width: 300px;
        box-shadow: none;
      }

      body.sidebar-open {
        overflow: auto;
      }

      #sidebarOverlay,
      .mobile-toggle,
      .sidebar-close {
        display: none;
      }

      .chat-area {
        padding-left: 0;
        min-height: 100vh;
      }
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Sidebar containing configuration and thread list -->
    <aside class="sidebar" aria-label="Settings panel" aria-hidden="true">
      <div class="sidebar-header">
        <h2>Settings</h2>
        <button type="button" id="closeSidebarBtn" class="sidebar-close" aria-label="Close settings">×</button>
      </div>
      <div class="form-group">
        <label for="endpointSelect">Quick-start endpoints</label>
        <select id="endpointSelect"></select>
      </div>
      <p id="endpointOnboardingHint" class="hint-text" role="note">
        Tip: Pick an API endpoint above to get started. Already configured this app on another device?
        <button type="button" id="importSettingsShortcut" class="link-btn">Import your settings file</button>
        instead.
      </p>
      <div class="form-group">
        <label for="endpointInput">API endpoint</label>
        <input type="text" id="endpointInput" placeholder="https://api.example.com/v1" />
      </div>
      <p id="endpointHint" class="hint-text" role="note"></p>
      <div class="form-group">
        <label for="modelSelect">Model</label>
        <div class="model-select-row">
          <button type="button" id="refreshModelsBtn">Refresh model list</button>
          <select id="modelSelect"></select>
        </div>
      </div>
      <div class="form-group">
        <label for="tokenInput">API token</label>
        <input type="password" id="tokenInput" placeholder="sk-..." />
      </div>
      <hr />
      <div class="threads-header">
        <h3>Chats</h3>
      </div>
      <ul id="threadList" class="thread-list"></ul>
      <div class="actions" role="group" aria-label="Chat history and settings import and export">
        <div class="action-group">
          <span class="action-label">Chat history:</span>
          <button
            type="button"
            id="exportBtn"
            class="icon-btn"
            title="Export chat history"
            aria-label="Export chat history"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 3a1 1 0 0 1 1 1v7.586l2.293-2.293a1 1 0 1 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 0 1 1.414-1.414L11 11.586V4a1 1 0 0 1 1-1Z"
              />
              <path
                d="M5 15a1 1 0 0 1 1 1v2h12v-2a1 1 0 1 1 2 0v3a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1Z"
              />
            </svg>
            <span class="sr-only">Export chat history</span>
          </button>
          <button
            type="button"
            id="importBtn"
            class="icon-btn"
            title="Import chat history"
            aria-label="Import chat history"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 21a1 1 0 0 1-1-1v-7.586l-2.293 2.293a1 1 0 0 1-1.414-1.414l4-4a1 1 0 0 1 1.414 0l4 4a1 1 0 0 1-1.414 1.414L13 12.414V20a1 1 0 0 1-1 1Z"
              />
              <path
                d="M19 9a1 1 0 0 1-1-1V6H6v2a1 1 0 0 1-2 0V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1Z"
              />
            </svg>
            <span class="sr-only">Import chat history</span>
          </button>
          <input type="file" id="importInput" accept="application/json" style="display: none;" />
        </div>
        <div class="action-group">
          <span class="action-label">Settings:</span>
          <button
            type="button"
            id="exportConfigBtn"
            class="icon-btn"
            title="Export settings"
            aria-label="Export settings"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 3a1 1 0 0 1 1 1v7.586l2.293-2.293a1 1 0 1 1 1.414 1.414l-4 4a1 1 0 0 1-1.414 0l-4-4a1 1 0 0 1 1.414-1.414L11 11.586V4a1 1 0 0 1 1-1Z"
              />
              <path
                d="M5 15a1 1 0 0 1 1 1v2h12v-2a1 1 0 1 1 2 0v3a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1Z"
              />
            </svg>
            <span class="sr-only">Export settings</span>
          </button>
          <button
            type="button"
            id="importConfigBtn"
            class="icon-btn"
            title="Import settings"
            aria-label="Import settings"
          >
            <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path
                d="M12 21a1 1 0 0 1-1-1v-7.586l-2.293 2.293a1 1 0 0 1-1.414-1.414l4-4a1 1 0 0 1 1.414 0l4 4a1 1 0 0 1-1.414 1.414L13 12.414V20a1 1 0 0 1-1 1Z"
              />
              <path
                d="M19 9a1 1 0 0 1-1-1V6H6v2a1 1 0 0 1-2 0V5a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1Z"
              />
            </svg>
            <span class="sr-only">Import settings</span>
          </button>
          <input type="file" id="importConfigInput" accept="application/json" style="display: none;" />
        </div>
      </div>
    </aside>
    <div id="sidebarOverlay" aria-hidden="true"></div>

    <!-- Main chat area -->
    <main class="chat-area">
      <div id="chatHeader" class="chat-header">
        <button type="button" id="openSidebarBtn" class="mobile-toggle" aria-label="Open settings">☰</button>
        <input type="text" id="threadTitleInput" class="thread-title" placeholder="Chat title" />
        <button
          type="button"
          id="aboutBtn"
          class="about-btn"
          aria-label="About &amp; Privacy"
          aria-haspopup="dialog"
          aria-expanded="false"
        >i</button>
      </div>
      <div id="promoBanner" class="promo-banner" role="region" aria-label="Journal Foundation notice" hidden>
        <span>
          Private local chat demo by
          <a href="https://JournalFoundation.org" target="_blank" rel="noopener">JournalFoundation.org</a>.
          Save this page to run it offline.
        </span>
        <button id="dismissPromoBtn" class="dismiss" aria-label="Dismiss notice">×</button>
      </div>
      <div id="chatNotice" class="chat-notice" role="status" aria-live="polite" hidden></div>
      <div
        id="authGuidance"
        class="chat-notice"
        role="status"
        aria-live="polite"
        aria-hidden="true"
        hidden
      >
        <p><strong>Trouble authenticating?</strong> Double-check your endpoint or import your saved settings file.</p>
        <div class="notice-actions" role="group" aria-label="Authentication help actions">
          <button type="button" id="authGuideEndpointBtn">Select API endpoint</button>
          <button type="button" id="authGuideImportBtn" class="secondary">Import settings</button>
        </div>
      </div>
      <div id="systemPromptContainer" class="system-prompt-container">
        <label for="systemPromptInput">System prompt:</label>
        <textarea id="systemPromptInput" placeholder="You are a helpful assistant."></textarea>
      </div>
      <div id="messages" class="messages"></div>
      <form id="messageForm" class="message-form">
        <div class="message-input-wrapper">
          <textarea id="messageInput" placeholder="Type your message" rows="3"></textarea>
          <div id="messageInputOverlay" class="message-input-overlay" aria-hidden="true"></div>
        </div>
        <button type="submit" id="sendBtn">Send</button>
      </form>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite" aria-hidden="true" hidden></div>

  <div id="modalBackdrop" class="modal-backdrop" hidden></div>
  <div id="aboutModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="aboutTitle" hidden>
    <div class="sheet" role="document">
      <button type="button" class="modal-close" id="aboutCloseBtn" aria-label="Close">×</button>
      <h2 id="aboutTitle">Private &amp; Local — About this demo</h2>
      <p><strong>This is a single static HTML file.</strong> There is no backend, no database, and nothing on a server to capture your data. Your chats are stored in your browser.</p>

      <h3>How to run it anywhere</h3>
      <ul>
        <li><strong>Desktop:</strong> Right-click → <em>Save Page As…</em>, then open the saved file.</li>
        <li><strong>iPhone (Safari):</strong> Share → <em>Add to Home Screen</em>, or Share → <em>Save to Files</em>, then open it.</li>
      </ul>

      <h3>What’s stored locally</h3>
      <ul>
        <li><code>localStorage</code>: chat threads and messages.</li>
        <li><code>sessionStorage</code>: settings (endpoint, token, models) for the current session.</li>
      </ul>
      <p>No network calls happen unless you set an API endpoint and press <em>Send</em> (or <em>Refresh model list</em>).</p>

      <div class="cta-row">
        <a id="jfSiteLink" class="cta-link" href="https://JournalFoundation.org" target="_blank" rel="noopener">JournalFoundation.org</a>
        <a id="githubProjectLink" class="cta-link" href="https://github.com/JournalFoundation/privatelocalchat" target="_blank" rel="noopener">Fork / contribute on GitHub</a>
      </div>

      <div class="cta-row">
        <button id="downloadPageBtn" class="primary">Download this page</button>
      </div>

      <p class="fine-print">
        Tip: You can also open this dialog directly with <code>?about=1</code> in the URL.
      </p>
    </div>
  </div>

  <script>
    /*
     * Private Chat Client: lightweight local chat UI for chat completion APIs.
     *
     * This implementation is based on PR #2 from the provided options.
     *
     * The script below manages chat threads, configuration, and interactions
     * with external API endpoints. It also enforces availability rules such
     * that a user cannot send a message until a thread is selected and the
     * endpoint and model are configured. Additionally, this version
     * supports pre-populating the chat title, system prompt, and message
     * fields via URL query parameters. See the parseUrlParams() function.
     */

    (() => {
      // DOM element references
      const endpointSelect = document.getElementById('endpointSelect');
      const endpointInput = document.getElementById('endpointInput');
      const tokenInput = document.getElementById('tokenInput');
      const modelSelect = document.getElementById('modelSelect');
      const refreshModelsBtn = document.getElementById('refreshModelsBtn');
      const endpointHint = document.getElementById('endpointHint');
      const threadList = document.getElementById('threadList');
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const importInput = document.getElementById('importInput');
      const exportConfigBtn = document.getElementById('exportConfigBtn');
      const importConfigBtn = document.getElementById('importConfigBtn');
      const importConfigInput = document.getElementById('importConfigInput');
      const importSettingsShortcut = document.getElementById('importSettingsShortcut');
      const openSidebarBtn = document.getElementById('openSidebarBtn');
      const closeSidebarBtn = document.getElementById('closeSidebarBtn');
      const sidebarOverlay = document.getElementById('sidebarOverlay');
      const sidebarEl = document.querySelector('.sidebar');
      const threadTitleInput = document.getElementById('threadTitleInput');
      const systemPromptInput = document.getElementById('systemPromptInput');
      const chatNotice = document.getElementById('chatNotice');
      const messagesEl = document.getElementById('messages');
      const messageForm = document.getElementById('messageForm');
      const messageInput = document.getElementById('messageInput');
      const messageInputOverlay = document.getElementById('messageInputOverlay');
      const sendBtn = document.getElementById('sendBtn');
      const authGuidance = document.getElementById('authGuidance');
      const authGuideEndpointBtn = document.getElementById('authGuideEndpointBtn');
      const authGuideImportBtn = document.getElementById('authGuideImportBtn');
      const aboutBtn = document.getElementById('aboutBtn');
      const promoBanner = document.getElementById('promoBanner');
      const dismissPromoBtn = document.getElementById('dismissPromoBtn');
      const aboutModal = document.getElementById('aboutModal');
      const modalBackdrop = document.getElementById('modalBackdrop');
      const toast = document.getElementById('toast');
      const aboutCloseBtn = document.getElementById('aboutCloseBtn');
      const downloadPageBtn = document.getElementById('downloadPageBtn');

      // Application state
      let config = {
        endpoint: '',
        token: '',
        model: ''
      };
      let threads = [];
      let currentThreadId = null;
      let models = [];
      let openThreadMenu = null;
      let toastHideTimer = null;
      let consecutiveAuthErrors = 0;
      const desktopMediaQuery = window.matchMedia('(min-width: 900px)');

      const promptUnavailableNoticeMessage = "You can't start chatting until you set an LLM API endpoint.";

      const triggerEndpointGuidance = () => {
        showToast(promptUnavailableNoticeMessage);
        guideToEndpointSetup();
      };

      if (chatNotice) {
        chatNotice.addEventListener('click', () => {
          if (!chatNotice.classList.contains('requires-endpoint')) {
            return;
          }
          triggerEndpointGuidance();
        });
        chatNotice.addEventListener('keydown', event => {
          if (!chatNotice.classList.contains('requires-endpoint')) {
            return;
          }
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            triggerEndpointGuidance();
          }
        });
      }

      const defaults = { endpoint: '', token: '', model: '' };
      const CONFIG_KEY = 'chatConfig';
      const THREAD_KEY = 'chatThreads';
      const MODELS_KEY = 'chatModels';

      const endpointOptions = [
        {
          id: 'choose',
          label: 'Select an endpoint…',
          baseUrl: '',
          hint:
            'Pick a provider from the list to auto-fill the API endpoint and see instructions for locating its API key. You can still paste any custom endpoint below. Requests use <code>/chat/completions</code> for the configured base URL.'
        },
        {
          id: 'openai',
          label: 'OpenAI',
          baseUrl: 'https://api.openai.com/v1',
          hint:
            'Access GPT-4o and other OpenAI models. Sign in at <a href="https://platform.openai.com/" target="_blank" rel="noopener">platform.openai.com</a>, open <strong>API keys</strong>, click <strong>Create new secret key</strong>, name it, and copy the value immediately (it is shown only once). Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'openrouter',
          label: 'OpenRouter — multi-model hub',
          baseUrl: 'https://openrouter.ai/api/v1',
          hint:
            'Aggregator of Anthropic, Mistral, Llama 3 and more. Create an account at <a href="https://openrouter.ai/" target="_blank" rel="noopener">openrouter.ai</a>, open <strong>API Keys</strong>, click <strong>Create Key</strong>, set an optional spend limit, and copy the key (it is shown only once). Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'vercel',
          label: 'Vercel AI Gateway',
          baseUrl: 'https://ai-gateway.vercel.sh/v1',
          hint:
            'Proxy that fans out to Anthropic, Groq, Mistral, Perplexity and more. In the Vercel dashboard go to <strong>AI Gateway → API Keys</strong>, click <strong>Create key</strong>, name it, and copy the generated key for your requests. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'cloudflare',
          label: 'Cloudflare AI Gateway',
          baseUrl: 'https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/compat',
          hint:
            'Routes to Gemini, Cohere, Perplexity and other providers. In the Cloudflare dashboard open <strong>AI → AI Gateway</strong>, choose your gateway, add provider API keys under <strong>Provider Keys</strong>, and optionally generate an access token to send in the <code>cf-aig-authorization</code> header. Use this base URL; the client calls <code>/chat/completions</code> automatically.',
          detect: value => value.startsWith('https://gateway.ai.cloudflare.com/')
        },
        {
          id: 'anyscale',
          label: 'Anyscale Endpoints',
          baseUrl: 'https://api.endpoints.anyscale.com/v1',
          hint:
            'Hosted Mixtral and Llama family models. Sign in at <a href="https://www.anyscale.com/" target="_blank" rel="noopener">Anyscale</a>, open the Endpoints dashboard, and create an API key to authenticate with this URL. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'groq',
          label: 'Groq — low-latency inference',
          baseUrl: 'https://api.groq.com/openai/v1',
          hint:
            'Runs LLaMA and Mixtral models on Groq hardware. After logging in to <a href="https://console.groq.com/" target="_blank" rel="noopener">Groq Cloud</a>, open <strong>Developers</strong>, click <strong>Create API Key</strong>, and copy the key when it appears. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'together',
          label: 'Together AI',
          baseUrl: 'https://api.together.xyz/v1',
          hint:
            'Unified endpoint for Meta, Mistral, DeepSeek, Google and more. Create an account at <a href="https://api.together.xyz/" target="_blank" rel="noopener">Together AI</a>, visit <strong>Settings → API Keys</strong>, generate a key, and paste it here. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'fireworks',
          label: 'Fireworks AI',
          baseUrl: 'https://api.fireworks.ai/inference/v1',
          hint:
            'Fireworks hosts Mixtral-based instruct models and other OSS LLMs. In the Fireworks dashboard open <strong>API Keys</strong>, click <strong>Create API Key</strong>, and copy the value for use with this endpoint. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'deepseek',
          label: 'DeepSeek',
          baseUrl: 'https://api.deepseek.com',
          hint:
            'Access DeepSeek’s reasoning models. Sign in to <a href="https://platform.deepseek.com/" target="_blank" rel="noopener">DeepSeek</a>, choose <strong>Access API → API Keys</strong>, create a key, and store it securely because it is only shown once. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'hyperbolic',
          label: 'Hyperbolic',
          baseUrl: 'https://api.hyperbolic.xyz/v1',
          hint:
            'Scaled-down OSS models with OpenAI compatibility. Log in to Hyperbolic, create an API key in your dashboard, and use it alongside this base URL. The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'deepinfra',
          label: 'DeepInfra',
          baseUrl: 'https://api.deepinfra.com/v1/openai',
          hint:
            'Chat, completion, and embedding APIs for open-source LLMs. Generate an API key from the <a href="https://deepinfra.com/" target="_blank" rel="noopener">DeepInfra</a> console and include it in the <code>Authorization</code> header. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'perplexity',
          label: 'Perplexity Sonar',
          baseUrl: 'https://api.perplexity.ai',
          hint:
            'Grounded web-search models with an OpenAI-style API. From the Perplexity account dashboard create an API key, then use it with this endpoint. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'huggingface-router',
          label: 'Hugging Face router',
          baseUrl: 'https://router.huggingface.co/v1',
          hint:
            'Route to providers like Novita, Groq or Together via the model name. Create or reuse a Hugging Face access token at <a href="https://huggingface.co/settings/tokens" target="_blank" rel="noopener">huggingface.co/settings/tokens</a> and pass it as your API key. Use this base URL; the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'huggingface-tgi',
          label: 'Hugging Face TGI (local)',
          baseUrl: 'http://localhost:8080/v1',
          hint:
            'Run <strong>text-generation-inference</strong> locally and point the client at this base URL. No API key is required when running on your own machine, and the client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'lorax',
          label: 'LoRAX (local server)',
          baseUrl: 'http://127.0.0.1:8080/v1',
          hint:
            'LoRAX exposes an OpenAI-compatible endpoint on your workstation. Start the server and use any placeholder key if authentication is disabled. The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'lmstudio',
          label: 'LM Studio (desktop)',
          baseUrl: 'http://localhost:1234/v1',
          hint:
            'LM Studio ships with an OpenAI-compatible API. Start the local server from the LM Studio interface and use this URL (the API key field can stay empty). The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'ollama',
          label: 'Ollama (local)',
          baseUrl: 'http://localhost:11434/v1',
          hint:
            'Ollama serves local LLaMA, Mistral and Phi models. No API key is required—any string will work—so you can leave the token blank. The client calls <code>/chat/completions</code> automatically.'
        },
        {
          id: 'runpod',
          label: 'RunPod vLLM worker',
          baseUrl: 'https://api.runpod.ai/v2/ENDPOINT_ID/openai/v1',
          hint:
            'Each RunPod worker exposes an OpenAI-compatible interface. Replace <code>ENDPOINT_ID</code> with your worker ID and use the API key from the RunPod dashboard. Use this base URL; the client calls <code>/chat/completions</code> automatically.',
          detect: value => value.startsWith('https://api.runpod.ai/v2/')
        },
        {
          id: 'baseten',
          label: 'Baseten (model-specific URL)',
          baseUrl: 'https://{model_id}.api.baseten.co/environments/{environment}/content/v1',
          hint:
            'Deploy models with Engine Builder to receive an OpenAI-style endpoint. Use the format <code>https://{model_id}.api.baseten.co/environments/&lt;env&gt;/content/v1</code> and authenticate with a Baseten personal API key created from <strong>Account → API keys</strong>. Use this base URL; the client calls <code>/chat/completions</code> automatically.',
          detect: value => value.includes('.api.baseten.co')
        },
        {
          id: 'custom',
          label: 'Custom / self-hosted endpoint',
          baseUrl: '',
          hint:
            'Paste any OpenAI-compatible base URL, such as a corporate gateway or another local server. Remember to include the provider’s API key (if required). Changes save automatically as you edit. Requests use <code>/chat/completions</code> for this base URL.'
        }
      ];

      const escapeHtml = str =>
        (str || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');

      function getEndpointOptionById(id) {
        return endpointOptions.find(option => option.id === id) || endpointOptions[0];
      }

      function findEndpointOptionForValue(value) {
        const normalized = (value || '').trim().toLowerCase();
        if (!normalized) {
          return getEndpointOptionById('choose');
        }
        const match = endpointOptions.find(option => {
          if (option.baseUrl) {
            const compare = option.baseUrl.toLowerCase();
            if (compare && normalized.startsWith(compare)) {
              return true;
            }
          }
          if (typeof option.detect === 'function') {
            try {
              if (option.detect(normalized)) {
                return true;
              }
            } catch (err) {
              console.warn('Endpoint detection failed for option', option.id, err);
            }
          }
          return false;
        });
        return match || getEndpointOptionById('custom');
      }

      function updateEndpointHint(option, currentValue) {
        if (!endpointHint) return;
        const target = option || getEndpointOptionById('choose');
        let html = target.hint || '';
        if (target.id === 'custom' && currentValue) {
          html += `<br /><strong>Using:</strong> <code>${escapeHtml(currentValue)}</code>`;
        } else if (target.baseUrl) {
          html += `<br /><strong>Endpoint URL:</strong> <code>${escapeHtml(target.baseUrl)}</code>`;
        }
        if (!html) {
          endpointHint.textContent = '';
          endpointHint.hidden = true;
        } else {
          endpointHint.innerHTML = html;
          endpointHint.hidden = false;
        }
      }

      function syncEndpointControls(value) {
        const option = findEndpointOptionForValue(value);
        if (endpointSelect) {
          endpointSelect.value = option.id;
        }
        updateEndpointHint(option, value);
      }

      function persistEndpointValue(value, { refresh = false } = {}) {
        const normalized = (value || '').trim();
        if (config.endpoint !== normalized) {
          config.endpoint = normalized;
          persistConfig();
        }
        syncEndpointControls(normalized);
        updateChatAvailability();
        consecutiveAuthErrors = 0;
        updateAuthGuidance();
        if (refresh) {
          refreshModels({ silent: true });
        }
      }

      function persistTokenValue(value, { refresh = false } = {}) {
        const normalized = (value || '').trim();
        if (config.token !== normalized) {
          config.token = normalized;
          persistConfig();
        }
        consecutiveAuthErrors = 0;
        updateAuthGuidance();
        if (refresh) {
          refreshModels({ silent: true });
        }
      }

      function applyEndpointOption(optionId) {
        const option = getEndpointOptionById(optionId);
        if (!option) return;
        if (option.id === 'choose') {
          endpointInput.value = '';
        } else if (option.baseUrl) {
          endpointInput.value = option.baseUrl;
        }
        persistEndpointValue(endpointInput.value, { refresh: true });
      }

      function populateEndpointSelect() {
        if (!endpointSelect) return;
        endpointSelect.innerHTML = '';
        endpointOptions.forEach(option => {
          const opt = document.createElement('option');
          opt.value = option.id;
          opt.textContent = option.label;
          endpointSelect.appendChild(opt);
        });
        const currentValue = endpointInput ? endpointInput.value.trim() : '';
        syncEndpointControls(currentValue);
      }

      const readJson = (store, key, fallback) => {
        try {
          const raw = store.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch (err) {
          console.warn(`Could not read ${key}:`, err);
          return fallback;
        }
      };

      const writeJson = (store, key, value) => {
        try {
          store.setItem(key, JSON.stringify(value));
        } catch (err) {
          console.error(`Failed to write ${key}:`, err);
        }
      };

      const persistConfig = () => writeJson(sessionStorage, CONFIG_KEY, config);

      function openAbout() {
        if (!aboutModal || !modalBackdrop) return;
        aboutModal.hidden = false;
        modalBackdrop.hidden = false;
        document.body.style.overflow = 'hidden';
        if (aboutBtn) {
          aboutBtn.setAttribute('aria-expanded', 'true');
        }
        if (aboutCloseBtn) {
          aboutCloseBtn.focus();
        }
      }

      function closeAbout() {
        if (!aboutModal || !modalBackdrop) return;
        if (aboutModal.hidden) return;
        aboutModal.hidden = true;
        modalBackdrop.hidden = true;
        document.body.style.overflow = '';
        if (aboutBtn) {
          aboutBtn.setAttribute('aria-expanded', 'false');
          aboutBtn.focus();
        }
      }

      function maybeShowPromo() {
        if (!promoBanner) return;
        const dismissed = sessionStorage.getItem('promoDismissed') === '1';
        promoBanner.hidden = dismissed;
      }

      function buildPreloadUrl() {
        const baseHref = window.location.href.split('#')[0].split('?')[0];
        const params = new URLSearchParams();
        const title = (threadTitleInput?.value || '').trim();
        const system = (systemPromptInput?.value || '').trim();
        const prompt = (messageInput?.value || '').trim();
        if (title) params.set('title', title);
        if (system) params.set('system', system);
        if (prompt) params.set('prompt', prompt);
        const query = params.toString();
        return query ? `${baseHref}?${query}` : baseHref;
      }

      function initMarketing() {
        maybeShowPromo();
        const qs = new URLSearchParams(window.location.search);
        if (qs.get('about') === '1') {
          openAbout();
        }
      }

      function loadModels() {
        models = readJson(sessionStorage, MODELS_KEY, []);
      }

      function storeModels(list) {
        models = [...new Set(list.filter(Boolean))];
        writeJson(sessionStorage, MODELS_KEY, models);
      }

      /**
       * Render the model dropdown. If no models are loaded the select is disabled.
       * @param {string[]} list list of model ids
       * @param {string} desiredModel previously selected model
       */
      function renderModelOptions(list, desiredModel) {
        const ids = [...new Set(list.filter(Boolean))];
        modelSelect.innerHTML = '';
        if (!ids.length) {
          modelSelect.disabled = true;
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No models loaded';
          modelSelect.appendChild(option);
          if (config.model) {
            config.model = '';
            persistConfig();
          }
          updateChatAvailability();
          return;
        }

        ids.forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = id;
          modelSelect.appendChild(option);
        });

        modelSelect.disabled = false;
        const selection = ids.includes(desiredModel) ? desiredModel : ids[0];
        modelSelect.value = selection;
        if (config.model !== selection) {
          config.model = selection;
          persistConfig();
        }
        updateChatAvailability();
      }

      function loadConfig() {
        config = { ...defaults, ...readJson(sessionStorage, CONFIG_KEY, {}) };
        endpointInput.value = config.endpoint;
        tokenInput.value = config.token;
        syncEndpointControls(config.endpoint);
        renderModelOptions(models, config.model);
      }

      function loadThreads() {
        const storedThreads = readJson(localStorage, THREAD_KEY, []);
        threads = Array.isArray(storedThreads) ? storedThreads : [];
      }

      function saveThreads() {
        writeJson(localStorage, THREAD_KEY, threads);
      }

      function generateThreadId() {
        return `${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 10)}`;
      }

      function createThread({ title = 'New chat', systemPrompt = '', messages = [] } = {}) {
        const id = generateThreadId();
        const normalizedTitle = typeof title === 'string' ? title : 'New chat';
        const normalizedSystemPrompt = typeof systemPrompt === 'string' ? systemPrompt : '';
        const thread = {
          id,
          title: normalizedTitle,
          systemPrompt: normalizedSystemPrompt,
          messages: Array.isArray(messages) ? [...messages] : []
        };
        threads.push(thread);
        saveThreads();
        return id;
      }

      function ensureThreadExists() {
        const hasValidThread = threads.some(thread => thread && typeof thread.id === 'string' && thread.id);
        if (hasValidThread) {
          return null;
        }
        return createThread();
      }

      const getThread = id => threads.find(t => t.id === id);
      const currentThread = () => getThread(currentThreadId);
      const updateThread = mutator => {
        const thread = currentThread();
        if (!thread) return null;
        mutator(thread);
        saveThreads();
        return thread;
      };

      /**
       * Derive the state of the chat. A thread, endpoint and model must be selected
       * before sending messages. This helper returns booleans representing those
       * conditions as well as an aggregate "ready" flag.
       */
      function getChatState() {
        const thread = currentThread();
        const hasThread = Boolean(thread);
        const hasEndpoint = Boolean((config.endpoint || '').trim());
        const hasModel = Boolean((config.model || '').trim());
        return {
          hasThread,
          hasEndpoint,
          hasModel,
          ready: hasThread && hasEndpoint && hasModel
        };
      }

      /**
       * Enable or disable the send button depending on whether a message is ready to send.
       * @param {boolean} isReady indicates if chat conditions are met
       */
      function updateSendButtonDisabled(isReady) {
        if (!sendBtn || !messageInput) return;
        const hasContent = Boolean(messageInput.value.trim());
        sendBtn.disabled = !isReady || !hasContent || messageInput.disabled;
      }

      /**
       * Update the notice block above the chat area to indicate missing prerequisites.
       * When there are no issues this hides the notice, otherwise lists guidance.
       * @param {object} state output from getChatState()
       */
      function updateChatNotice(state) {
        if (!chatNotice) return;
        const instructions = [];
        if (!state.hasEndpoint) {
          instructions.push('Enter an API endpoint in Settings to send messages.');
        }
        if (state.hasEndpoint && !state.hasModel) {
          instructions.push('Refresh and select a model before chatting.');
        }
        if (!state.hasThread) {
          instructions.push('Create or select a chat from the sidebar.');
        }

        const requiresEndpoint = !state.hasEndpoint;
        chatNotice.classList.toggle('requires-endpoint', requiresEndpoint);
        if (requiresEndpoint) {
          chatNotice.setAttribute('tabindex', '0');
        } else {
          chatNotice.removeAttribute('tabindex');
        }

        chatNotice.innerHTML = '';
        if (!instructions.length) {
          chatNotice.classList.remove('active');
          chatNotice.setAttribute('aria-hidden', 'true');
          chatNotice.hidden = true;
          if (messageInput) {
            messageInput.removeAttribute('aria-describedby');
          }
          return;
        }

        const list = document.createElement('ul');
        instructions.forEach(text => {
          const item = document.createElement('li');
          item.textContent = text;
          list.appendChild(item);
        });
        chatNotice.appendChild(list);
        chatNotice.classList.add('active');
        chatNotice.setAttribute('aria-hidden', 'false');
        chatNotice.hidden = false;
        if (messageInput) {
          messageInput.setAttribute('aria-describedby', 'chatNotice');
        }
      }

      /**
       * Based on chat state, enable/disable inputs and update placeholders
       * to guide the user toward completing the necessary steps. When a
       * message has been prefilled via URL, we leave that value intact
       * so the user can see it even if sending is disabled.
       */
      function updateChatAvailability() {
        const state = getChatState();
        const placeholder = !state.hasThread
          ? 'Select or start a chat to enable messaging'
          : !state.hasEndpoint
            ? 'Add an API endpoint to enable messaging'
            : !state.hasModel
              ? 'Select a model to enable messaging'
              : 'Type your message';
        threadTitleInput.disabled = !state.hasThread;
        systemPromptInput.disabled = !state.hasThread;

        // Only update the message placeholder if the input is empty. If there's
        // pre-filled text we leave it alone so that the user can see it.
        if (!messageInput.value) {
          messageInput.placeholder = placeholder;
        }
        // Disable input when not ready, but leave the value alone.
        messageInput.disabled = !state.ready;
        if (state.ready) {
          messageForm.classList.remove('disabled');
          messageForm.setAttribute('aria-disabled', 'false');
        } else {
          messageForm.classList.add('disabled');
          messageForm.setAttribute('aria-disabled', 'true');
        }
        updateChatNotice(state);
        updateSendButtonDisabled(state.ready);
      }

      function hideToast() {
        if (!toast) return;
        toast.classList.remove('visible');
        toast.setAttribute('aria-hidden', 'true');
        if (toastHideTimer) {
          window.clearTimeout(toastHideTimer);
          toastHideTimer = null;
        }
        window.setTimeout(() => {
          if (!toast.classList.contains('visible')) {
            toast.hidden = true;
          }
        }, 180);
      }

      function showToast(message, duration = 3200) {
        if (!toast) return;
        if (toastHideTimer) {
          window.clearTimeout(toastHideTimer);
          toastHideTimer = null;
        }
        toast.textContent = message;
        toast.hidden = false;
        toast.setAttribute('aria-hidden', 'false');
        toast.classList.remove('visible');
        // Force reflow so the animation retriggers when showToast runs rapidly.
        void toast.offsetWidth;
        toast.classList.add('visible');
        toastHideTimer = window.setTimeout(() => {
          toastHideTimer = null;
          hideToast();
        }, duration);
      }

      /**
       * Ensure the chat history list is always tall enough to keep the "Start new chat"
       * control visible on compact screens. The minimum height is equal to the combined
       * height of the available items up to a maximum of 2.5 list items.
       */
      function updateThreadListMinHeight() {
        if (!threadList) {
          return;
        }
        const items = threadList.querySelectorAll('li');
        if (!items.length) {
          threadList.style.removeProperty('min-height');
          return;
        }

        const itemHeights = Array.from(items, item => {
          const rect = item.getBoundingClientRect();
          const styles = window.getComputedStyle(item);
          const marginTop = parseFloat(styles.marginTop) || 0;
          const marginBottom = parseFloat(styles.marginBottom) || 0;
          return rect.height + marginTop + marginBottom;
        });

        let minHeight = 0;
        if (itemHeights.length === 1) {
          minHeight = itemHeights[0];
        } else if (itemHeights.length === 2) {
          minHeight = itemHeights[0] + itemHeights[1];
        } else {
          minHeight = itemHeights[0] + itemHeights[1] + itemHeights[2] * 0.5;
        }

        threadList.style.minHeight = `${minHeight}px`;
      }

      /**
       * Render the list of chat threads in the sidebar. Each entry is clickable
       * and optionally exposes a menu for renaming or deleting the thread.
       */
      function renderThreadList() {
        closeThreadMenu();
        threadList.innerHTML = '';
        const createLi = document.createElement('li');
        createLi.classList.add('new-thread-item');
        const createBtn = document.createElement('button');
        createBtn.type = 'button';
        createBtn.classList.add('new-thread-button');
        createBtn.textContent = 'Start new chat';
        createBtn.addEventListener('click', event => {
          event.stopPropagation();
          newThread();
        });
        createLi.appendChild(createBtn);
        threadList.appendChild(createLi);
        threads.forEach(thread => {
          const threadName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
          const li = document.createElement('li');
          li.dataset.id = thread.id;
          if (thread.id === currentThreadId) {
            li.classList.add('selected');
          }
          const nameSpan = document.createElement('span');
          nameSpan.classList.add('thread-name');
          nameSpan.textContent = threadName;
          li.appendChild(nameSpan);

          const menuBtn = document.createElement('button');
          menuBtn.type = 'button';
          menuBtn.classList.add('thread-menu-btn');
          menuBtn.setAttribute('aria-label', `Options for ${threadName}`);
          menuBtn.textContent = '⋮';
          menuBtn.addEventListener('click', event => {
            event.stopPropagation();
            toggleThreadMenu(thread.id, menuBtn);
          });
          li.appendChild(menuBtn);

          li.addEventListener('click', () => selectThread(thread.id));
          threadList.appendChild(li);
        });

        updateThreadListMinHeight();
      }

      /**
       * Select a thread by ID, updating UI and state accordingly. If the
       * thread doesn't exist, the chat inputs are disabled.
       * @param {string} id thread identifier
       */
      function selectThread(id) {
        closeThreadMenu();
        currentThreadId = id;
        const thread = getThread(id);
        if (!thread) {
          updateChatAvailability();
          return;
        }
        // Populate title and system prompt
        threadTitleInput.value = thread.title || '';
        systemPromptInput.value = thread.systemPrompt || '';
        // Render messages
        renderMessages(thread);
        // Re-render thread list to highlight current
        renderThreadList();
        closeSidebar();
        updateChatAvailability();
      }

      /**
       * Create a new chat thread. This generates a unique id and inserts
       * an empty conversation into the list. The new thread becomes the
       * currently selected one.
       */
      function newThread() {
        const id = createThread();
        renderThreadList();
        selectThread(id);
      }

      /**
       * Delete a chat thread by id. After deletion the next available thread
       * becomes current. If none remain, the chat area is cleared and
       * disabled.
       * @param {string} targetId id to delete
       */
      function deleteThread(targetId = currentThreadId) {
        if (!targetId) return;
        const index = threads.findIndex(t => t.id === targetId);
        if (index === -1) return;
        const confirmed = window.confirm('Delete this chat thread?');
        if (!confirmed) return;
        threads.splice(index, 1);
        saveThreads();
        const ensuredId = ensureThreadExists();
        const firstThreadWithId = threads.find(thread => thread && typeof thread.id === 'string' && thread.id);
        currentThreadId = firstThreadWithId?.id || ensuredId || null;
        if (currentThreadId) {
          selectThread(currentThreadId);
          return;
        }
        threadTitleInput.value = '';
        systemPromptInput.value = '';
        messagesEl.innerHTML = '';
        renderThreadList();
        updateChatAvailability();
      }

      /**
       * Rename the given thread by prompting the user for a new title. The
       * current thread title input updates along with the list.
       * @param {string} threadId id of the thread to rename
       */
      function renameThread(threadId) {
        const thread = getThread(threadId);
        if (!thread) return;
        const currentName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
        const newName = window.prompt('Rename chat', currentName);
        if (newName === null) return;
        thread.title = newName.trim() || 'Untitled';
        saveThreads();
        renderThreadList();
        if (threadId === currentThreadId) {
          threadTitleInput.value = thread.title;
        }
      }

      function threadToMarkdown(thread) {
        if (!thread) return '';
        const title = typeof thread.title === 'string' && thread.title.trim() ? thread.title.trim() : 'Untitled chat';
        const lines = [`# ${title}`];
        const prompt = typeof thread.systemPrompt === 'string' ? thread.systemPrompt.trim() : '';
        if (prompt) {
          lines.push('', '## System Prompt', '', prompt);
        }
        const messages = Array.isArray(thread.messages) ? thread.messages : [];
        if (messages.length) {
          lines.push('', '## Messages', '');
          messages.forEach((message, index) => {
            const rawRole = typeof message?.role === 'string' ? message.role.trim() : '';
            const role = rawRole ? rawRole.charAt(0).toUpperCase() + rawRole.slice(1) : 'Message';
            let content = '';
            if (message && typeof message.content === 'string') {
              content = message.content;
            } else if (message && message.content != null) {
              try {
                content = JSON.stringify(message.content, null, 2);
              } catch (err) {
                content = String(message.content);
              }
            }
            if (!content.trim()) {
              content = '_No content_';
            }
            lines.push(`### ${index + 1}. ${role}`, '', content, '');
          });
        } else {
          lines.push('', '_No messages yet._');
        }
        return lines.join('\n');
      }

      function exportThreadMarkdown(threadId = currentThreadId) {
        if (!threadId) return;
        const thread = getThread(threadId);
        if (!thread) return;
        const markdown = threadToMarkdown(thread);
        const blob = new Blob([markdown], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const safeTitle = typeof thread.title === 'string' && thread.title.trim()
          ? thread.title.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '')
          : 'chat';
        const filename = `${safeTitle || 'chat'}-${thread.id}.md`;
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Render all messages for a given thread. This simply loops over the
       * stored messages and creates elements for each role.
       * @param {object} thread chat thread
       */
      function renderMessages(thread) {
        messagesEl.innerHTML = '';
        thread.messages.forEach(msg => {
          const div = document.createElement('div');
          div.classList.add('message', msg.role);
          div.textContent = msg.content;
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      /**
       * Helper to append a message to the current thread, saving and re-rendering.
       * @param {string} role message role ('user', 'assistant', 'system')
       * @param {string} content message content
       */
      function addMessage(role, content) {
        const thread = updateThread(t => t.messages.push({ role, content }));
        if (thread) {
          renderMessages(thread);
        }
      }

      /**
       * Open the sidebar. Adds a class to the body that triggers the CSS
       * transform and disables page scrolling on mobile.
       */
      function openSidebar(arg) {
        let options = {};
        if (typeof Event !== 'undefined' && arg instanceof Event) {
          arg.preventDefault();
        } else if (arg && typeof arg === 'object') {
          options = arg;
        }
        document.body.classList.add('sidebar-open');
        closeThreadMenu();
        updateSidebarAria();
        const focusTarget = options.focusTarget;
        const skipDefaultFocus = Boolean(options.skipDefaultFocus || focusTarget);
        if (focusTarget && typeof focusTarget.focus === 'function') {
          setTimeout(() => {
            try {
              focusTarget.focus({ preventScroll: true });
            } catch (err) {
              focusTarget.focus();
            }
          }, 0);
        } else if (!skipDefaultFocus && closeSidebarBtn) {
          setTimeout(() => closeSidebarBtn.focus(), 0);
        }
      }

      /**
       * Close the sidebar and optionally restore focus to the hamburger button.
       * @param {object} options options.restoreFocus when true focuses the open button
       */
      function closeSidebar(options = {}) {
        const wasOpen = document.body.classList.contains('sidebar-open');
        if (wasOpen) {
          document.body.classList.remove('sidebar-open');
          if (options.restoreFocus && openSidebarBtn && !desktopMediaQuery.matches) {
            openSidebarBtn.focus({ preventScroll: true });
          }
        }
        updateSidebarAria();
      }

      function updateSidebarAria() {
        if (!sidebarEl) return;
        const hidden = !desktopMediaQuery.matches && !document.body.classList.contains('sidebar-open');
        sidebarEl.setAttribute('aria-hidden', hidden ? 'true' : 'false');
      }

      function guideToEndpointSetup() {
        openSidebar({ focusTarget: endpointSelect, skipDefaultFocus: true });
        if (!endpointSelect) {
          return;
        }
        const highlightClass = 'highlight-pulse';
        const cleanupHighlight = () => endpointSelect.classList.remove(highlightClass);
        endpointSelect.addEventListener('blur', cleanupHighlight, { once: true });
        window.requestAnimationFrame(() => {
          try {
            endpointSelect.scrollIntoView({ behavior: 'smooth', block: 'center' });
          } catch (err) {
            // Ignore scroll errors.
          }
          endpointSelect.classList.add(highlightClass);
          window.setTimeout(cleanupHighlight, 1800);
          try {
            if (typeof endpointSelect.showPicker === 'function') {
              endpointSelect.showPicker();
            } else {
              endpointSelect.focus({ preventScroll: true });
            }
          } catch (err) {
            try {
              endpointSelect.focus({ preventScroll: true });
            } catch (focusErr) {
              endpointSelect.focus();
            }
          }
        });
      }

      function updateAuthGuidance() {
        if (!authGuidance) {
          return;
        }
        if (consecutiveAuthErrors >= 2) {
          authGuidance.classList.add('active');
          authGuidance.hidden = false;
          authGuidance.setAttribute('aria-hidden', 'false');
        } else {
          authGuidance.classList.remove('active');
          authGuidance.hidden = true;
          authGuidance.setAttribute('aria-hidden', 'true');
        }
      }

      /**
       * Close the thread action menu if open.
       */
      function closeThreadMenu() {
        if (!openThreadMenu) return;
        document.removeEventListener('mousedown', openThreadMenu.outsideHandler);
        document.removeEventListener('keydown', openThreadMenu.keyHandler);
        if (openThreadMenu.menuEl.parentNode) {
          openThreadMenu.menuEl.parentNode.removeChild(openThreadMenu.menuEl);
        }
        openThreadMenu = null;
      }

      /**
       * Toggle the thread action menu for a given thread. The menu appears
       * anchored to the provided element and is removed when clicking outside
       * or pressing escape.
       * @param {string} threadId id of the thread
       * @param {HTMLElement} anchor element to anchor the menu to
       */
      function toggleThreadMenu(threadId, anchor) {
        if (openThreadMenu && openThreadMenu.anchor === anchor) {
          closeThreadMenu();
          return;
        }
        closeThreadMenu();
        const menu = document.createElement('div');
        menu.classList.add('thread-menu');

        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', () => {
          closeThreadMenu();
          renameThread(threadId);
        });
        menu.appendChild(renameBtn);

        const exportThreadBtn = document.createElement('button');
        exportThreadBtn.textContent = 'Export (.md)';
        exportThreadBtn.addEventListener('click', () => {
          closeThreadMenu();
          exportThreadMarkdown(threadId);
        });
        menu.appendChild(exportThreadBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.classList.add('delete');
        deleteBtn.addEventListener('click', () => {
          closeThreadMenu();
          deleteThread(threadId);
        });
        menu.appendChild(deleteBtn);

        const copyLinkBtn = document.createElement('button');
        copyLinkBtn.textContent = 'Copy link with current title/system/prompt';
        copyLinkBtn.addEventListener('click', async () => {
          const url = buildPreloadUrl();
          try {
            await navigator.clipboard.writeText(url);
            showToast('Link copied to clipboard');
          } catch (err) {
            window.prompt('Copy this link:', url);
          } finally {
            closeThreadMenu();
          }
        });
        menu.appendChild(copyLinkBtn);

        document.body.appendChild(menu);
        const rect = anchor.getBoundingClientRect();
        menu.style.top = `${window.scrollY + rect.bottom + 4}px`;
        menu.style.left = `${window.scrollX + rect.left}px`;
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = document.documentElement.clientWidth;
        if (menuRect.right > viewportWidth) {
          const adjustedLeft = Math.max(8, viewportWidth - menuRect.width - 8);
          menu.style.left = `${window.scrollX + adjustedLeft}px`;
        }

        const outsideHandler = event => {
          if (menu.contains(event.target) || anchor.contains(event.target)) {
            return;
          }
          closeThreadMenu();
        };
        const keyHandler = event => {
          if (event.key === 'Escape') {
            closeThreadMenu();
          }
        };
        document.addEventListener('mousedown', outsideHandler);
        document.addEventListener('keydown', keyHandler);
        openThreadMenu = {
          menuEl: menu,
          anchor,
          outsideHandler,
          keyHandler
        };
      }

      /**
       * Send the current message to the API. This prevents default form
       * submission behaviour, validates chat readiness and content, then
       * appends the user message, sends the request and appends the reply.
       * It also shows a loading indicator while the API call is in flight.
       * @param {Event} event form submit event
       */
      async function handleSendMessage(event) {
        event.preventDefault();
        const state = getChatState();
        if (!state.ready) {
          if (!state.hasEndpoint) {
            triggerEndpointGuidance();
          }
          updateChatAvailability();
          return;
        }
        const message = messageInput.value.trim();
        if (!message) {
          updateSendButtonDisabled(state.ready);
          return;
        }
        addMessage('user', message);
        messageInput.value = '';
        updateSendButtonDisabled(state.ready);

        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.classList.add('loading');
        messagesEl.appendChild(loadingIndicator);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          const reply = await sendToApi();
          consecutiveAuthErrors = 0;
          updateAuthGuidance();
          addMessage('assistant', reply);
        } catch (err) {
          console.error(err);
          addMessage('system', 'Error: ' + err.message);
          if (err && (err.isAuthError || err.status === 401 || err.status === 403)) {
            consecutiveAuthErrors = Math.min(consecutiveAuthErrors + 1, 3);
          } else {
            consecutiveAuthErrors = 0;
          }
          updateAuthGuidance();
        } finally {
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }
        }
      }

      /**
       * Send the conversation to the configured API endpoint. Uses the current
       * model and thread messages. Throws if required fields are missing or
       * the response status is not ok.
       */
      async function sendToApi() {
        if (!config.endpoint) {
          throw new Error('Endpoint is not configured.');
        }
        const thread = currentThread();
        if (!thread) {
          throw new Error('No thread selected.');
        }
        if (!config.model) {
          throw new Error('Model is not selected.');
        }
        const systemPrompt = thread.systemPrompt?.trim();
        const messagesForRequest = systemPrompt
          ? [{ role: 'system', content: systemPrompt }, ...thread.messages]
          : [...thread.messages];
        // Compose request payload. Adjust this object to match the API expected schema.
        const body = {
          model: config.model,
          messages: messagesForRequest
        };
        const headers = {
          'Content-Type': 'application/json'
        };
        // Include authorization header if token is provided
        if (config.token) {
          headers['Authorization'] = `Bearer ${config.token}`;
        }
        let chatEndpoint;
        try {
          chatEndpoint = deriveChatCompletionsUrl(config.endpoint);
        } catch (err) {
          throw new Error('Invalid endpoint: ' + err.message);
        }

        const response = await fetch(chatEndpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify(body)
        });
        if (!response.ok) {
          const error = new Error('API responded with status ' + response.status);
          error.status = response.status;
          if (response.status === 401 || response.status === 403) {
            error.isAuthError = true;
          }
          throw error;
        }
        // Parse JSON response. We expect a property `choices[0].message.content` similar to OpenAI.
        const data = await response.json();
        const choice = Array.isArray(data?.choices) && data.choices.length ? data.choices[0] : null;
        const reply = choice?.message?.content || choice?.text || (typeof data?.answer === 'string' ? data.answer : '');
        return reply || JSON.stringify(data);
      }

      /**
       * Given an endpoint (possibly relative) derive the URL for the models
       * endpoint. This attempts to find the nearest version segment and
       * replace the trailing path with 'models'.
       * @param {string} endpoint base endpoint
       */
      function deriveModelsUrl(endpoint) {
        let url;
        try {
          url = new URL(endpoint);
        } catch (err) {
          url = new URL(endpoint, window.location.href);
        }
        const segments = url.pathname.split('/').filter(Boolean);
        if (segments[segments.length - 1] === 'models') {
          url.search = '';
          url.hash = '';
          return url.toString();
        }

        let versionIndex = -1;
        for (let i = segments.length - 1; i >= 0; i--) {
          if (/^v\d+$/i.test(segments[i])) {
            versionIndex = i;
            break;
          }
        }
        const baseSegments = versionIndex !== -1 ? segments.slice(0, versionIndex + 1) : segments;
        url.pathname = '/' + [...baseSegments, 'models'].join('/');
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      /**
       * Given a base endpoint derive the chat completions URL. This appends a
       * single `/chat/completions` segment to the path while preserving other
       * segments and stripping query/hash components.
       * @param {string} endpoint base endpoint
       */
      function deriveChatCompletionsUrl(endpoint) {
        let url;
        try {
          url = new URL(endpoint);
        } catch (err) {
          url = new URL(endpoint, window.location.href);
        }
        const segments = url.pathname.split('/').filter(Boolean);
        const alreadySuffixed =
          segments.length >= 2 &&
          segments[segments.length - 2] === 'chat' &&
          segments[segments.length - 1] === 'completions';
        if (alreadySuffixed) {
          url.search = '';
          url.hash = '';
          return url.toString();
        }
        const cleanedSegments = [];
        for (let i = 0; i < segments.length; i += 1) {
          if (segments[i] === 'chat' && segments[i + 1] === 'completions') {
            i += 1;
            continue;
          }
          cleanedSegments.push(segments[i]);
        }
        cleanedSegments.push('chat', 'completions');
        url.pathname = '/' + cleanedSegments.join('/');
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      /**
       * Fetch the list of available models for the current endpoint and token.
       * Updates the dropdown with the returned ids. Silent mode suppresses
       * alerts for invalid endpoints or no models returned.
       * @param {object} opts silent: when true suppresses alert messages
       */
      async function refreshModels({ silent } = {}) {
        const endpoint = endpointInput.value.trim() || config.endpoint;
        if (!endpoint) {
          if (!silent) {
            alert('Set an endpoint before refreshing models.');
          }
          updateChatAvailability();
          return;
        }
        let modelsEndpoint;
        try {
          modelsEndpoint = deriveModelsUrl(endpoint);
        } catch (err) {
          console.error('Invalid endpoint:', err);
          if (!silent) {
            alert('Invalid endpoint: ' + err.message);
          }
          updateChatAvailability();
          return;
        }

        if (config.endpoint !== endpoint) {
          config.endpoint = endpoint;
          persistConfig();
        }

        refreshModelsBtn.disabled = true;
        const originalLabel = refreshModelsBtn.textContent;
        refreshModelsBtn.textContent = 'Loading...';
        try {
          const headers = { Accept: 'application/json' };
          const token = tokenInput.value.trim() || config.token;
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
            if (config.token !== token) {
              config.token = token;
              persistConfig();
            }
          }
          const response = await fetch(modelsEndpoint, { method: 'GET', headers });
          if (!response.ok) {
            throw new Error('Status ' + response.status);
          }
          const data = await response.json();
          const rawList = Array.isArray(data?.data)
            ? data.data
            : Array.isArray(data?.models)
              ? data.models
              : [];
          const ids = rawList
            .map(item => {
              if (typeof item === 'string') return item.trim();
              if (item && typeof item.id === 'string') return item.id.trim();
              if (item && typeof item.name === 'string') return item.name.trim();
              return '';
            })
            .filter(id => id.length > 0);
          if (!ids.length) {
            throw new Error('No models returned.');
          }
          storeModels(ids);
          renderModelOptions(models, config.model);
          if (!silent) {
            alert('Models updated.');
          }
        } catch (err) {
          console.error('Failed to refresh models:', err);
          if (!silent) {
            alert('Failed to load models: ' + err.message);
          }
        } finally {
          refreshModelsBtn.disabled = false;
          refreshModelsBtn.textContent = originalLabel;
          updateChatAvailability();
        }
      }

      /**
       * Export chat history to a JSON file. The user can download their
       * threads array as a structured JSON document.
       */
      function exportHistory() {
        const dataStr = JSON.stringify(threads, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-history.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Import chat history from a selected JSON file. The file is parsed
       * and, if valid, replaces the current threads list. Afterwards the
       * first thread is selected or the chat area is disabled if none.
       * @param {Event} event input change event
       */
      function importHistory(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imported = JSON.parse(e.target.result);
            if (Array.isArray(imported)) {
              threads = imported;
              saveThreads();
              const ensuredId = ensureThreadExists();
              renderThreadList();
              const firstThreadWithId = threads.find(thread => thread && typeof thread.id === 'string' && thread.id);
              const nextId = firstThreadWithId?.id || ensuredId || null;
              if (nextId) {
                selectThread(nextId);
              } else {
                currentThreadId = null;
                updateChatAvailability();
              }
              alert('Import successful');
            } else {
              alert('Invalid file format.');
            }
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
          // Reset input to allow re-importing same file later
          importInput.value = '';
        };
        reader.readAsText(file);
      }

      /**
       * Export the current config and model list to a JSON file. Includes
       * an exportedAt timestamp for reference.
       */
      function exportConfig() {
        const payload = {
          config: { ...config },
          models: [...models],
          exportedAt: new Date().toISOString()
        };
        const dataStr = JSON.stringify(payload, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-config.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function normalizeConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        return {
          endpoint: typeof raw.endpoint === 'string' ? raw.endpoint : '',
          token: typeof raw.token === 'string' ? raw.token : '',
          model: typeof raw.model === 'string' ? raw.model : ''
        };
      }

      /**
       * Import a configuration file. Extracts config and model list and
       * updates session storage accordingly. Will override current session
       * config but not modify saved threads.
       * @param {Event} event input change event
       */
      function importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imported = JSON.parse(e.target.result);
            const source = imported && typeof imported === 'object'
              ? (imported.config && typeof imported.config === 'object' ? imported.config : imported)
              : null;
            const nextConfig = normalizeConfig(source);
            if (!nextConfig) {
              alert('Invalid config file.');
              return;
            }
            config = { ...defaults, ...nextConfig };
            persistConfig();
            endpointInput.value = config.endpoint;
            tokenInput.value = config.token;
            syncEndpointControls(config.endpoint);
            consecutiveAuthErrors = 0;
            updateAuthGuidance();
            if (Array.isArray(imported?.models)) {
              storeModels(imported.models);
            }
            renderModelOptions(models, config.model);
            alert('Configuration imported.');
          } catch (err) {
            alert('Failed to import config: ' + err.message);
          }
          importConfigInput.value = '';
        };
        reader.readAsText(file);
      }

      /**
       * Parse the current URL's query parameters and, if any chat data is
       * provided, prepopulate a new chat thread. Supported parameters:
       *
       *   - title: the chat title
       *   - system: the system prompt
       *   - prompt: the initial message to prefill in the message input
       *
       * If at least one of these parameters is present, a new thread is
       * created (without altering existing ones) and selected. The chat
       * remains disabled until the user configures an endpoint and model.
       */
      function parseUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const titleParam = params.get('title') || params.get('chat') || params.get('name');
        const systemParam = params.get('system') || params.get('systemPrompt') || params.get('system_prompt');
        const promptParam = params.get('prompt') || params.get('message') || params.get('msg');
        // Only act if at least one parameter is present and no threads yet created via params
        if (titleParam || systemParam || promptParam) {
          // Create a new thread with provided values
          const threadDetails = {
            title: titleParam ? decodeURIComponent(titleParam) : 'New chat',
            systemPrompt: systemParam ? decodeURIComponent(systemParam) : ''
          };
          const id = createThread(threadDetails);
          currentThreadId = id;
          const threadObj = getThread(id);
          // Insert into UI
          renderThreadList();
          selectThread(id);
          // Overwrite fields with decoded values
          threadTitleInput.value = threadObj?.title ?? threadDetails.title;
          systemPromptInput.value = threadObj?.systemPrompt ?? threadDetails.systemPrompt;
          if (promptParam) {
            messageInput.value = decodeURIComponent(promptParam);
          }
          updateChatAvailability();
        }
      }

      /**
       * Initialize the application. Loads persisted models, config and threads
       * from storage, handles URL-based prepopulation, renders the thread
       * list and selects the first available thread. Also refreshes models
       * silently if an endpoint is provided without cached models.
       */
      function init() {
        populateEndpointSelect();
        loadModels();
        loadConfig();
        loadThreads();
        // Check if URL contains chat data and create a thread accordingly
        parseUrlParams();
        const ensuredId = ensureThreadExists();
        renderThreadList();
        // If a thread was created via URL params select it; otherwise pick the first existing
        const firstThreadWithId = threads.find(thread => thread && typeof thread.id === 'string' && thread.id);
        const targetThreadId = currentThreadId || ensuredId || firstThreadWithId?.id || null;
        if (targetThreadId) {
          selectThread(targetThreadId);
        } else {
          updateChatAvailability();
        }
        if (!models.length && config.endpoint) {
          refreshModels({ silent: true });
        }
      }
      init();
      updateAuthGuidance();

      // Attach event listeners
      if (endpointSelect) {
        endpointSelect.addEventListener('change', () => {
          applyEndpointOption(endpointSelect.value);
        });
      }
      if (endpointInput) {
        endpointInput.addEventListener('input', () => {
          syncEndpointControls(endpointInput.value.trim());
        });
        endpointInput.addEventListener('change', () => {
          persistEndpointValue(endpointInput.value, { refresh: true });
        });
      }
      if (tokenInput) {
        tokenInput.addEventListener('change', () => {
          persistTokenValue(tokenInput.value, { refresh: true });
        });
      }
      refreshModelsBtn.addEventListener('click', () => refreshModels());
      modelSelect.addEventListener('change', () => {
        config.model = modelSelect.value;
        persistConfig();
        updateChatAvailability();
      });
      messageForm.addEventListener('submit', handleSendMessage);
      messageInput.addEventListener('input', () => {
        updateSendButtonDisabled(getChatState().ready);
      });
      if (messageInputOverlay) {
        messageInputOverlay.addEventListener('click', () => {
          if (!messageInput || !messageInput.disabled) {
            return;
          }
          const state = getChatState();
          if (!state.hasEndpoint) {
            triggerEndpointGuidance();
          }
        });
      }
      if (toast) {
        toast.addEventListener('click', hideToast);
      }
      exportBtn.addEventListener('click', exportHistory);
      importBtn.addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', importHistory);
      exportConfigBtn.addEventListener('click', exportConfig);
      importConfigBtn.addEventListener('click', () => importConfigInput.click());
      importConfigInput.addEventListener('change', importConfig);
      if (importSettingsShortcut) {
        importSettingsShortcut.addEventListener('click', event => {
          event.preventDefault();
          if (importConfigInput) {
            importConfigInput.click();
          }
        });
      }
      if (authGuideEndpointBtn) {
        authGuideEndpointBtn.addEventListener('click', event => {
          event.preventDefault();
          guideToEndpointSetup();
        });
      }
      if (authGuideImportBtn) {
        authGuideImportBtn.addEventListener('click', event => {
          event.preventDefault();
          if (importConfigInput) {
            importConfigInput.click();
          }
        });
      }
      if (aboutBtn) {
        aboutBtn.addEventListener('click', openAbout);
      }
      if (aboutCloseBtn) {
        aboutCloseBtn.addEventListener('click', closeAbout);
      }
      if (modalBackdrop) {
        modalBackdrop.addEventListener('click', closeAbout);
      }
      window.addEventListener('resize', updateThreadListMinHeight);
      if (dismissPromoBtn) {
        dismissPromoBtn.addEventListener('click', () => {
          sessionStorage.setItem('promoDismissed', '1');
          maybeShowPromo();
        });
      }
      if (downloadPageBtn) {
        downloadPageBtn.addEventListener('click', () => {
          try {
            const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'private-chat.html';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
          } catch (err) {
            alert('If download is blocked by your browser, use “Save Page As…” instead.');
          }
        });
      }
      if (openSidebarBtn) {
        openSidebarBtn.addEventListener('click', openSidebar);
      }
      if (closeSidebarBtn) {
        closeSidebarBtn.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape') {
          if (aboutModal && !aboutModal.hidden) {
            closeAbout();
            return;
          }
          if (document.body.classList.contains('sidebar-open')) {
            closeSidebar({ restoreFocus: true });
            return;
          }
          closeThreadMenu();
        }
      });
      const handleViewportChange = event => {
        if (event.matches) {
          closeSidebar();
        }
        updateSidebarAria();
      };
      if (desktopMediaQuery.addEventListener) {
        desktopMediaQuery.addEventListener('change', handleViewportChange);
      } else if (desktopMediaQuery.addListener) {
        desktopMediaQuery.addListener(handleViewportChange);
      }
      updateSidebarAria();

      threadTitleInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.title = threadTitleInput.value.trim() || 'Untitled';
          renderThreadList();
        });
      });
      systemPromptInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.systemPrompt = systemPromptInput.value.trim();
        });
      });
      initMarketing();
    })();
  </script>
</body>
</html>
