<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Private Chat Client</title>
  <style>
    /* Minimal styling for the chat client UI. */

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #fff;
      color: #222;
      min-height: 100vh;
    }

    #app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Sidebar styling */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(85vw, 320px);
      background: #f4f4f4;
      border-right: 1px solid #ddd;
      box-shadow: 2px 0 12px rgba(0,0,0,0.15);
      padding: 16px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.25s ease;
      z-index: 1001;
    }

    body.sidebar-open .sidebar {
      transform: translateX(0);
    }

    body.sidebar-open {
      overflow: hidden;
    }

    .sidebar h2,
    .sidebar h3 {
      margin-top: 0;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      gap: 8px;
    }

    .sidebar-close {
      border: none;
      background: transparent;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 1;
      padding: 4px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #333;
    }

    input:disabled,
    textarea:disabled {
      background: #e9ecef;
      cursor: not-allowed;
    }

    textarea[readonly] {
      background: #f8f9fa;
      cursor: not-allowed;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .form-group button {
      width: 100%;
      padding: 8px;
      background: #007bff;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .form-group button:hover {
      background: #0056b3;
    }

    .threads-header {
      margin-top: 16px;
    }

    .threads-header h3 {
      margin: 0 0 12px 0;
    }

    .thread-list {
      list-style: none;
      padding: 0;
      margin: 0;
      flex: 1;
      overflow-y: auto;
    }

    .thread-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 4px;
    }

    .thread-list li.selected {
      background: #007bff;
      color: #fff;
    }

    .thread-list li:hover {
      background: #e2e6ea;
    }

    .thread-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .thread-menu-btn {
      border: none;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px 4px;
    }

    .thread-menu-btn:hover {
      color: #007bff;
    }

    .thread-list li.selected .thread-menu-btn:hover {
      color: #cfe2ff;
    }

    .thread-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      padding: 4px 0;
      min-width: 140px;
      z-index: 1000;
    }

    .thread-menu button {
      width: 100%;
      background: none;
      border: none;
      text-align: left;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .thread-menu button:hover {
      background: #f0f0f0;
    }

    .thread-menu button.delete {
      color: #c1121f;
    }

    .thread-list li.new-thread-item {
      display: block;
      padding: 0;
      background: none;
      margin-bottom: 8px;
    }

    .thread-list li.new-thread-item:hover {
      background: none;
    }

    .new-thread-button {
      width: 100%;
      border: none;
      background: #28a745;
      color: #fff;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .new-thread-button:hover {
      background: #1c7e32;
    }

    .actions {
      margin-top: 16px;
    }

    .actions button {
      width: 100%;
      margin-bottom: 8px;
      padding: 8px;
      background: #6c757d;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .actions button:hover {
      background: #565e64;
    }

    .model-select-row button {
      width: 100%;
      padding: 8px;
      font-size: 0.9rem;
    }

    .model-select-row button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .model-select-row select {
      width: 100%;
      margin-top: 8px;
    }

    /* Chat area styling */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-bottom: 1px solid #ddd;
    }

    .thread-title {
      flex: 1;
      font-size: 1.1rem;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .system-prompt-container {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }

    .system-prompt-container label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #555;
    }

    .system-prompt-container textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .messages {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      background: #fafafa;
    }

    .message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user {
      background: #e9f7ef;
      align-self: flex-end;
    }

    .message.assistant {
      background: #f1f1f1;
      align-self: flex-start;
    }

    .message.system {
      background: #fffbe6;
      border: 1px dashed #ccc;
    }

    .message-form {
      display: flex;
      padding: 12px;
      border-top: 1px solid #ddd;
      background: #f8f9fa;
    }

    .message-form textarea {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      font-size: 0.9rem;
      min-height: 60px;
    }

    .message-form button {
      margin-left: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .message-form button:hover {
      background: #0056b3;
    }

    .chat-status {
      margin: 0 12px 12px;
      padding: 12px;
      background: #fff4cd;
      border: 1px solid #f5c16c;
      border-radius: 4px;
      color: #7a5d00;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .chat-status p {
      margin: 0;
    }

    .chat-status p + p {
      margin-top: 4px;
    }

    .chat-status[hidden] {
      display: none !important;
    }

    /* Loading indicator styling */
    .loading {
      display: inline-block;
      border: 4px solid rgba(0,0,0,0.1);
      border-radius: 50%;
      border-top-color: #007bff;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    .mobile-toggle {
      border: none;
      background: transparent;
      font-size: 1.6rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px 6px;
      color: #007bff;
    }

    .mobile-toggle:focus,
    .sidebar-close:focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }

    #sidebarOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 1000;
    }

    body.sidebar-open #sidebarOverlay {
      opacity: 1;
      pointer-events: auto;
    }

    @media (min-width: 900px) {
      #app {
        flex-direction: row;
        min-height: 100vh;
      }

      .sidebar {
        position: relative;
        transform: none;
        width: 300px;
        max-width: 300px;
        box-shadow: none;
      }

      body.sidebar-open {
        overflow: auto;
      }

      #sidebarOverlay,
      .mobile-toggle,
      .sidebar-close {
        display: none;
      }

      .chat-area {
        padding-left: 0;
        min-height: 100vh;
      }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Sidebar containing configuration and thread list -->
    <aside class="sidebar" aria-label="Settings panel" aria-hidden="true">
      <div class="sidebar-header">
        <h2>Settings</h2>
        <button type="button" id="closeSidebarBtn" class="sidebar-close" aria-label="Close settings">×</button>
      </div>
      <div class="form-group">
        <label for="endpointInput">API endpoint</label>
        <input type="text" id="endpointInput" placeholder="https://api.example.com/v1/chat/completions" />
      </div>
      <div class="form-group">
        <label for="modelSelect">Model</label>
        <div class="model-select-row">
          <button type="button" id="refreshModelsBtn">Refresh model list</button>
          <select id="modelSelect"></select>
        </div>
      </div>
      <div class="form-group">
        <label for="tokenInput">API token</label>
        <input type="password" id="tokenInput" placeholder="sk-..." />
      </div>
      <div class="form-group">
        <button id="saveConfigBtn">Save config</button>
      </div>
      <hr />
      <div class="threads-header">
        <h3>Chats</h3>
      </div>
      <ul id="threadList" class="thread-list"></ul>
      <div class="actions">
        <button id="exportBtn">Export history</button>
        <input type="file" id="importInput" accept="application/json" style="display:none;" />
        <button id="importBtn">Import history</button>
        <button id="exportConfigBtn">Export settings</button>
        <input type="file" id="importConfigInput" accept="application/json" style="display:none;" />
        <button id="importConfigBtn">Import settings</button>
      </div>
    </aside>
    <div id="sidebarOverlay" aria-hidden="true"></div>

    <!-- Main chat area -->
    <main class="chat-area">
      <div id="chatHeader" class="chat-header">
        <button type="button" id="openSidebarBtn" class="mobile-toggle" aria-label="Open settings">☰</button>
        <input type="text" id="threadTitleInput" class="thread-title" placeholder="Chat title" />
      </div>
      <div id="systemPromptContainer" class="system-prompt-container">
        <label for="systemPromptInput">System prompt:</label>
        <textarea id="systemPromptInput" placeholder="You are a helpful assistant."></textarea>
      </div>
      <div id="messages" class="messages"></div>
      <div id="chatStatus" class="chat-status" role="status" aria-live="polite" hidden></div>
      <form id="messageForm" class="message-form">
        <textarea id="messageInput" placeholder="Type your message" rows="3"></textarea>
        <button type="submit" id="sendBtn">Send</button>
      </form>
    </main>
  </div>

  <script>
    /* Private Chat Client: lightweight local chat UI for chat completion APIs. */

    (() => {
      // DOM element references
      const endpointInput = document.getElementById('endpointInput');
      const tokenInput = document.getElementById('tokenInput');
      const modelSelect = document.getElementById('modelSelect');
      const refreshModelsBtn = document.getElementById('refreshModelsBtn');
      const saveConfigBtn = document.getElementById('saveConfigBtn');
      const threadList = document.getElementById('threadList');
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const importInput = document.getElementById('importInput');
      const exportConfigBtn = document.getElementById('exportConfigBtn');
      const importConfigBtn = document.getElementById('importConfigBtn');
      const importConfigInput = document.getElementById('importConfigInput');
      const openSidebarBtn = document.getElementById('openSidebarBtn');
      const closeSidebarBtn = document.getElementById('closeSidebarBtn');
      const sidebarOverlay = document.getElementById('sidebarOverlay');
      const sidebarEl = document.querySelector('.sidebar');
      const threadTitleInput = document.getElementById('threadTitleInput');
      const systemPromptInput = document.getElementById('systemPromptInput');
      const messagesEl = document.getElementById('messages');
      const messageForm = document.getElementById('messageForm');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const chatStatus = document.getElementById('chatStatus');

      // Application state
      let config = {
        endpoint: '',
        token: '',
        model: ''
      };
      let threads = [];
      let currentThreadId = null;
      let models = [];
      let openThreadMenu = null;
      const desktopMediaQuery = window.matchMedia('(min-width: 900px)');
      const defaultMessagePlaceholder = messageInput.getAttribute('placeholder') || 'Type your message';

      const defaults = { endpoint: '', token: '', model: '' };
      const CONFIG_KEY = 'chatConfig';
      const THREAD_KEY = 'chatThreads';
      const MODELS_KEY = 'chatModels';

      const readJson = (store, key, fallback) => {
        try {
          const raw = store.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch (err) {
          console.warn(`Could not read ${key}:`, err);
          return fallback;
        }
      };

      const writeJson = (store, key, value) => {
        try {
          store.setItem(key, JSON.stringify(value));
        } catch (err) {
          console.error(`Failed to write ${key}:`, err);
        }
      };

      const persistConfig = () => writeJson(sessionStorage, CONFIG_KEY, config);

      function loadModels() {
        models = readJson(sessionStorage, MODELS_KEY, []);
      }

      function storeModels(list) {
        models = [...new Set(list.filter(Boolean))];
        writeJson(sessionStorage, MODELS_KEY, models);
      }

      function renderModelOptions(list, desiredModel) {
        const ids = [...new Set(list.filter(Boolean))];
        modelSelect.innerHTML = '';
        if (!ids.length) {
          modelSelect.disabled = true;
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No models loaded';
          modelSelect.appendChild(option);
          if (config.model) {
            config.model = '';
            persistConfig();
          }
          updateChatState();
          return;
        }

        ids.forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = id;
          modelSelect.appendChild(option);
        });

        modelSelect.disabled = false;
        const selection = ids.includes(desiredModel) ? desiredModel : ids[0];
        modelSelect.value = selection;
        if (config.model !== selection) {
          config.model = selection;
          persistConfig();
        }
        updateChatState();
      }

      function loadConfig() {
        config = { ...defaults, ...readJson(sessionStorage, CONFIG_KEY, {}) };
        endpointInput.value = config.endpoint;
        tokenInput.value = config.token;
        renderModelOptions(models, config.model);
      }

      function saveConfig() {
        config = {
          endpoint: endpointInput.value.trim(),
          token: tokenInput.value.trim(),
          model: modelSelect.value.trim()
        };
        persistConfig();
        updateChatState();
        alert('Configuration saved for this session.');
        refreshModels({ silent: true });
      }

      function loadThreads() {
        threads = readJson(localStorage, THREAD_KEY, []);
      }

      function saveThreads() {
        writeJson(localStorage, THREAD_KEY, threads);
      }

      const getThread = id => threads.find(t => t.id === id);
      const currentThread = () => getThread(currentThreadId);
      const updateThread = mutator => {
        const thread = currentThread();
        if (!thread) return null;
        mutator(thread);
        saveThreads();
        return thread;
      };

      function updateChatState() {
        const hasThreads = threads.length > 0;
        const thread = currentThread();
        const hasThread = Boolean(thread);
        const endpoint = (config.endpoint || '').trim();
        const model = (config.model || '').trim();
        const issues = [];
        const addIssue = text => {
          if (text && !issues.includes(text)) {
            issues.push(text);
          }
        };

        if (!hasThreads) {
          addIssue('Start a new chat to begin.');
        } else if (!hasThread) {
          addIssue('Select a chat to begin.');
        }

        threadTitleInput.disabled = !hasThread;
        systemPromptInput.disabled = !hasThread;

        let messagePlaceholder = defaultMessagePlaceholder;
        if (!hasThread) {
          messagePlaceholder = hasThreads
            ? 'Select a chat to start messaging.'
            : 'Create a chat to start messaging.';
        }

        if (!endpoint) {
          addIssue('Enter and save an API endpoint in Settings.');
          if (hasThread) {
            messagePlaceholder = 'Enter and save an API endpoint in Settings.';
          }
        }

        if (!model) {
          const modelIssue = models.length
            ? 'Select a model to use for this chat.'
            : 'Refresh models from your API before chatting.';
          addIssue(modelIssue);
          if (hasThread && endpoint) {
            messagePlaceholder = models.length
              ? 'Select a model to send messages.'
              : 'Load models to choose one.';
          }
        }

        const canSend = hasThread && endpoint && model;

        messageInput.disabled = !hasThread;
        messageInput.readOnly = hasThread && !canSend;
        if (canSend) {
          messagePlaceholder = defaultMessagePlaceholder;
        }
        messageInput.placeholder = messagePlaceholder;
        sendBtn.disabled = !canSend;

        if (chatStatus) {
          chatStatus.innerHTML = '';
          chatStatus.hidden = issues.length === 0;
          issues.forEach(issue => {
            const p = document.createElement('p');
            p.textContent = issue;
            chatStatus.appendChild(p);
          });
        }
      }

      function renderThreadList() {
        closeThreadMenu();
        threadList.innerHTML = '';
        const createLi = document.createElement('li');
        createLi.classList.add('new-thread-item');
        const createBtn = document.createElement('button');
        createBtn.type = 'button';
        createBtn.classList.add('new-thread-button');
        createBtn.textContent = 'Start new chat';
        createBtn.addEventListener('click', event => {
          event.stopPropagation();
          newThread();
        });
        createLi.appendChild(createBtn);
        threadList.appendChild(createLi);
        threads.forEach(thread => {
          const threadName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
          const li = document.createElement('li');
          li.dataset.id = thread.id;
          if (thread.id === currentThreadId) {
            li.classList.add('selected');
          }
          const nameSpan = document.createElement('span');
          nameSpan.classList.add('thread-name');
          nameSpan.textContent = threadName;
          li.appendChild(nameSpan);

          const menuBtn = document.createElement('button');
          menuBtn.type = 'button';
          menuBtn.classList.add('thread-menu-btn');
          menuBtn.setAttribute('aria-label', `Options for ${threadName}`);
          menuBtn.textContent = '⋮';
          menuBtn.addEventListener('click', event => {
            event.stopPropagation();
            toggleThreadMenu(thread.id, menuBtn);
          });
          li.appendChild(menuBtn);

          li.addEventListener('click', () => selectThread(thread.id));
          threadList.appendChild(li);
        });
        updateChatState();
      }

      function selectThread(id) {
        closeThreadMenu();
        currentThreadId = id;
        const thread = getThread(id);
        if (!thread) return;
        // Populate title and system prompt
        threadTitleInput.value = thread.title || '';
        systemPromptInput.value = thread.systemPrompt || '';
        // Render messages
        renderMessages(thread);
        // Re-render thread list to highlight current
        renderThreadList();
        closeSidebar();
        updateChatState();
      }

      function newThread() {
        const id = Date.now().toString();
        threads.push({ id, title: 'New chat', systemPrompt: '', messages: [] });
        saveThreads();
        renderThreadList();
        selectThread(id);
      }

      function deleteThread(targetId = currentThreadId) {
        if (!targetId) return;
        const index = threads.findIndex(t => t.id === targetId);
        if (index === -1) return;
        const confirmed = window.confirm('Delete this chat thread?');
        if (!confirmed) return;
        threads.splice(index, 1);
        saveThreads();
        currentThreadId = threads[0]?.id || null;
        if (currentThreadId) {
          selectThread(currentThreadId);
          return;
        }
        threadTitleInput.value = '';
        systemPromptInput.value = '';
        messagesEl.innerHTML = '';
        renderThreadList();
      }

      function renameThread(threadId) {
        const thread = getThread(threadId);
        if (!thread) return;
        const currentName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
        const newName = window.prompt('Rename chat', currentName);
        if (newName === null) return;
        thread.title = newName.trim() || 'Untitled';
        saveThreads();
        renderThreadList();
        if (threadId === currentThreadId) {
          threadTitleInput.value = thread.title;
        }
      }

      function renderMessages(thread) {
        messagesEl.innerHTML = '';
        thread.messages.forEach(msg => {
          const div = document.createElement('div');
          div.classList.add('message', msg.role);
          div.textContent = msg.content;
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function addMessage(role, content) {
        const thread = updateThread(t => t.messages.push({ role, content }));
        if (thread) {
          renderMessages(thread);
        }
      }

      function openSidebar() {
        document.body.classList.add('sidebar-open');
        closeThreadMenu();
        if (closeSidebarBtn) {
          setTimeout(() => closeSidebarBtn.focus(), 0);
        }
        updateSidebarAria();
      }

      function closeSidebar(options = {}) {
        const wasOpen = document.body.classList.contains('sidebar-open');
        if (wasOpen) {
          document.body.classList.remove('sidebar-open');
          if (options.restoreFocus && openSidebarBtn && !desktopMediaQuery.matches) {
            openSidebarBtn.focus({ preventScroll: true });
          }
        }
        updateSidebarAria();
      }

      function updateSidebarAria() {
        if (!sidebarEl) return;
        const hidden = !desktopMediaQuery.matches && !document.body.classList.contains('sidebar-open');
        sidebarEl.setAttribute('aria-hidden', hidden ? 'true' : 'false');
      }

      function closeThreadMenu() {
        if (!openThreadMenu) return;
        document.removeEventListener('mousedown', openThreadMenu.outsideHandler);
        document.removeEventListener('keydown', openThreadMenu.keyHandler);
        if (openThreadMenu.menuEl.parentNode) {
          openThreadMenu.menuEl.parentNode.removeChild(openThreadMenu.menuEl);
        }
        openThreadMenu = null;
      }

      function toggleThreadMenu(threadId, anchor) {
        if (openThreadMenu && openThreadMenu.anchor === anchor) {
          closeThreadMenu();
          return;
        }
        closeThreadMenu();
        const menu = document.createElement('div');
        menu.classList.add('thread-menu');

        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', () => {
          closeThreadMenu();
          renameThread(threadId);
        });
        menu.appendChild(renameBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.classList.add('delete');
        deleteBtn.addEventListener('click', () => {
          closeThreadMenu();
          deleteThread(threadId);
        });
        menu.appendChild(deleteBtn);

        document.body.appendChild(menu);
        const rect = anchor.getBoundingClientRect();
        menu.style.top = `${window.scrollY + rect.bottom + 4}px`;
        menu.style.left = `${window.scrollX + rect.left}px`;
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = document.documentElement.clientWidth;
        if (menuRect.right > viewportWidth) {
          const adjustedLeft = Math.max(8, viewportWidth - menuRect.width - 8);
          menu.style.left = `${window.scrollX + adjustedLeft}px`;
        }

        const outsideHandler = event => {
          if (menu.contains(event.target) || anchor.contains(event.target)) {
            return;
          }
          closeThreadMenu();
        };
        const keyHandler = event => {
          if (event.key === 'Escape') {
            closeThreadMenu();
          }
        };
        document.addEventListener('mousedown', outsideHandler);
        document.addEventListener('keydown', keyHandler);
        openThreadMenu = {
          menuEl: menu,
          anchor,
          outsideHandler,
          keyHandler
        };
      }

      async function handleSendMessage(event) {
        event.preventDefault();
        if (!currentThreadId || sendBtn.disabled) {
          updateChatState();
          return;
        }
        const message = messageInput.value.trim();
        if (!message) return;
        addMessage('user', message);
        messageInput.value = '';
        sendBtn.disabled = true;
        messageInput.readOnly = true;

        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.classList.add('loading');
        messagesEl.appendChild(loadingIndicator);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          const reply = await sendToApi();
          addMessage('assistant', reply);
        } catch (err) {
          console.error(err);
          addMessage('system', 'Error: ' + err.message);
        } finally {
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }
          updateChatState();
        }
      }

      async function sendToApi() {
        if (!config.endpoint) {
          throw new Error('Endpoint is not configured.');
        }
        const thread = currentThread();
        if (!thread) {
          throw new Error('No thread selected.');
        }
        if (!config.model) {
          throw new Error('Model is not selected.');
        }
        const systemPrompt = thread.systemPrompt?.trim();
        const messagesForRequest = systemPrompt
          ? [{ role: 'system', content: systemPrompt }, ...thread.messages]
          : [...thread.messages];
        // Compose request payload. Adjust this object to match the API expected schema.
        const body = {
          model: config.model,
          messages: messagesForRequest
        };
        const headers = {
          'Content-Type': 'application/json'
        };
        // Include authorization header if token is provided
        if (config.token) {
          headers['Authorization'] = `Bearer ${config.token}`;
        }
        const response = await fetch(config.endpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify(body)
        });
        if (!response.ok) {
          throw new Error('API responded with status ' + response.status);
        }
        // Parse JSON response. We expect a property `choices[0].message.content` similar to OpenAI.
        const data = await response.json();
        const choice = Array.isArray(data?.choices) && data.choices.length ? data.choices[0] : null;
        const reply = choice?.message?.content || choice?.text || (typeof data?.answer === 'string' ? data.answer : '');
        return reply || JSON.stringify(data);
      }

      function deriveModelsUrl(endpoint) {
        let url;
        try {
          url = new URL(endpoint);
        } catch (err) {
          url = new URL(endpoint, window.location.href);
        }
        const segments = url.pathname.split('/').filter(Boolean);
        if (segments[segments.length - 1] === 'models') {
          url.search = '';
          url.hash = '';
          return url.toString();
        }
        const versionIndex = segments.findIndex(seg => /^v\d+$/i.test(seg));
        let baseSegments;
        if (versionIndex !== -1) {
          baseSegments = segments.slice(0, versionIndex + 1);
        } else if (segments.length > 0) {
          baseSegments = segments.slice(0, -1);
        } else {
          baseSegments = [];
        }
        const pathSegments = baseSegments.length ? baseSegments.concat('models') : ['models'];
        url.pathname = '/' + pathSegments.join('/');
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      async function refreshModels({ silent } = {}) {
        const endpoint = endpointInput.value.trim() || config.endpoint;
        if (!endpoint) {
          if (!silent) {
            alert('Set an endpoint before refreshing models.');
          }
          updateChatState();
          return;
        }
        let modelsEndpoint;
        try {
          modelsEndpoint = deriveModelsUrl(endpoint);
        } catch (err) {
          console.error('Invalid endpoint:', err);
          if (!silent) {
            alert('Invalid endpoint: ' + err.message);
          }
          updateChatState();
          return;
        }

        if (config.endpoint !== endpoint) {
          config.endpoint = endpoint;
          persistConfig();
        }

        refreshModelsBtn.disabled = true;
        const originalLabel = refreshModelsBtn.textContent;
        refreshModelsBtn.textContent = 'Loading...';
        try {
          const headers = { Accept: 'application/json' };
          const token = tokenInput.value.trim() || config.token;
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
            if (config.token !== token) {
              config.token = token;
              persistConfig();
            }
          }
          const response = await fetch(modelsEndpoint, { method: 'GET', headers });
          if (!response.ok) {
            throw new Error('Status ' + response.status);
          }
          const data = await response.json();
          const rawList = Array.isArray(data?.data)
            ? data.data
            : Array.isArray(data?.models)
              ? data.models
              : [];
          const ids = rawList
            .map(item => {
              if (typeof item === 'string') return item.trim();
              if (item && typeof item.id === 'string') return item.id.trim();
              if (item && typeof item.name === 'string') return item.name.trim();
              return '';
            })
            .filter(id => id.length > 0);
          if (!ids.length) {
            throw new Error('No models returned.');
          }
          storeModels(ids);
          renderModelOptions(models, config.model);
          if (!silent) {
            alert('Models updated.');
          }
        } catch (err) {
          console.error('Failed to refresh models:', err);
          if (!silent) {
            alert('Failed to load models: ' + err.message);
          }
        } finally {
          refreshModelsBtn.disabled = false;
          refreshModelsBtn.textContent = originalLabel;
          updateChatState();
        }
      }

      function exportHistory() {
        const dataStr = JSON.stringify(threads, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-history.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function importHistory(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const imported = JSON.parse(e.target.result);
            if (Array.isArray(imported)) {
              threads = imported;
              saveThreads();
              renderThreadList();
              if (threads.length) {
                selectThread(threads[0].id);
              }
              alert('Import successful');
            } else {
              alert('Invalid file format.');
            }
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
          // Reset input to allow re-importing same file later
          importInput.value = '';
        };
        reader.readAsText(file);
      }

      function exportConfig() {
        const payload = {
          config: { ...config },
          models: [...models],
          exportedAt: new Date().toISOString()
        };
        const dataStr = JSON.stringify(payload, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-config.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function normalizeConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        return {
          endpoint: typeof raw.endpoint === 'string' ? raw.endpoint : '',
          token: typeof raw.token === 'string' ? raw.token : '',
          model: typeof raw.model === 'string' ? raw.model : ''
        };
      }

      function importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const imported = JSON.parse(e.target.result);
            const source = imported && typeof imported === 'object'
              ? (imported.config && typeof imported.config === 'object' ? imported.config : imported)
              : null;
            const nextConfig = normalizeConfig(source);
            if (!nextConfig) {
              alert('Invalid config file.');
              return;
            }
            config = { ...defaults, ...nextConfig };
            persistConfig();
            endpointInput.value = config.endpoint;
            tokenInput.value = config.token;
            if (Array.isArray(imported?.models)) {
              storeModels(imported.models);
            }
            renderModelOptions(models, config.model);
            alert('Configuration imported.');
          } catch (err) {
            alert('Failed to import config: ' + err.message);
          }
          importConfigInput.value = '';
        };
        reader.readAsText(file);
      }

      refreshModelsBtn.addEventListener('click', () => refreshModels());
      modelSelect.addEventListener('change', () => {
        config.model = modelSelect.value;
        persistConfig();
        updateChatState();
      });
      saveConfigBtn.addEventListener('click', saveConfig);
      messageForm.addEventListener('submit', handleSendMessage);
      exportBtn.addEventListener('click', exportHistory);
      importBtn.addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', importHistory);
      exportConfigBtn.addEventListener('click', exportConfig);
      importConfigBtn.addEventListener('click', () => importConfigInput.click());
      importConfigInput.addEventListener('change', importConfig);
      if (openSidebarBtn) {
        openSidebarBtn.addEventListener('click', openSidebar);
      }
      if (closeSidebarBtn) {
        closeSidebarBtn.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape') {
          if (document.body.classList.contains('sidebar-open')) {
            closeSidebar({ restoreFocus: true });
            return;
          }
          closeThreadMenu();
        }
      });
      const handleViewportChange = event => {
        if (event.matches) {
          closeSidebar();
        }
        updateSidebarAria();
      };
      if (desktopMediaQuery.addEventListener) {
        desktopMediaQuery.addEventListener('change', handleViewportChange);
      } else if (desktopMediaQuery.addListener) {
        desktopMediaQuery.addListener(handleViewportChange);
      }
      updateSidebarAria();

      threadTitleInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.title = threadTitleInput.value.trim() || 'Untitled';
          renderThreadList();
        });
      });
      systemPromptInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.systemPrompt = systemPromptInput.value.trim();
        });
      });

      function init() {
        loadModels();
        loadConfig();
        loadThreads();
        renderThreadList();
        const firstThread = threads[0];
        if (firstThread) {
          selectThread(firstThread.id);
        }
        if (!models.length && config.endpoint) {
          refreshModels({ silent: true });
        }
        updateChatState();
      }
      init();
    })();
  </script>
</body>
</html>
