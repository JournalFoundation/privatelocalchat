<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Private Chat Client</title>
  <style>
    /* Minimal styling for the chat client UI. */

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #fff;
      color: #222;
      min-height: 100vh;
    }

    #app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Sidebar styling */
    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(85vw, 320px);
      background: #f4f4f4;
      border-right: 1px solid #ddd;
      box-shadow: 2px 0 12px rgba(0, 0, 0, 0.15);
      padding: 16px;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      transform: translateX(-100%);
      transition: transform 0.25s ease;
      z-index: 1001;
    }

    body.sidebar-open .sidebar {
      transform: translateX(0);
    }

    body.sidebar-open {
      overflow: hidden;
    }

    .sidebar h2,
    .sidebar h3 {
      margin-top: 0;
    }

    .sidebar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      gap: 8px;
    }

    .sidebar-close {
      border: none;
      background: transparent;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 1;
      padding: 4px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #333;
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .form-group button {
      width: 100%;
      padding: 8px;
      background: #007bff;
      border: none;
      border-radius: 4px;
      color: #fff;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .form-group button:hover {
      background: #0056b3;
    }

    .threads-header {
      margin-top: 16px;
    }

    .threads-header h3 {
      margin: 0 0 12px 0;
    }

    .thread-list {
      list-style: none;
      padding: 0;
      margin: 0;
      flex: 1;
      overflow-y: auto;
    }

    .thread-list li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 4px;
    }

    .thread-list li.selected {
      background: #007bff;
      color: #fff;
    }

    .thread-list li:hover {
      background: #e2e6ea;
    }

    .thread-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .thread-menu-btn {
      border: none;
      background: transparent;
      color: inherit;
      cursor: pointer;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px 4px;
    }

    .thread-menu-btn:hover {
      color: #007bff;
    }

    .thread-list li.selected .thread-menu-btn:hover {
      color: #cfe2ff;
    }

    .thread-menu {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      padding: 4px 0;
      min-width: 140px;
      z-index: 1000;
    }

    .thread-menu button {
      width: 100%;
      background: none;
      border: none;
      text-align: left;
      padding: 8px 12px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .thread-menu button:hover {
      background: #f0f0f0;
    }

    .thread-menu button.delete {
      color: #c1121f;
    }

    .thread-list li.new-thread-item {
      display: block;
      padding: 0;
      background: none;
      margin-bottom: 8px;
    }

    .thread-list li.new-thread-item:hover {
      background: none;
    }

    .new-thread-button {
      width: 100%;
      border: none;
      background: #28a745;
      color: #fff;
      padding: 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .new-thread-button:hover {
      background: #1c7e32;
    }

    .actions {
      margin-top: 16px;
    }

    .actions button {
      width: 100%;
      margin-bottom: 8px;
      padding: 8px;
      background: #6c757d;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .actions button:hover {
      background: #565e64;
    }

    .model-select-row button {
      width: 100%;
      padding: 8px;
      font-size: 0.9rem;
    }

    .model-select-row button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .model-select-row select {
      width: 100%;
      margin-top: 8px;
    }

    /* Chat area styling */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .chat-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-bottom: 1px solid #ddd;
    }

    .about-btn {
      min-width: 36px;
      height: 36px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      color: #007bff;
      font-weight: 700;
      cursor: pointer;
    }

    .promo-banner {
      position: sticky;
      top: 0;
      z-index: 5;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 12px;
      background: #fff8e1;
      border-bottom: 1px solid #f0c36d;
      color: #7a5200;
      font-size: 0.9rem;
    }

    .promo-banner a {
      color: #7a5200;
      text-decoration: underline;
    }

    .promo-banner .dismiss {
      border: none;
      background: transparent;
      font-size: 1.2rem;
      line-height: 1;
      cursor: pointer;
      color: #7a5200;
    }

    .thread-title {
      flex: 1;
      font-size: 1.1rem;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .system-prompt-container {
      padding: 8px 12px;
      border-bottom: 1px solid #ddd;
    }

    .system-prompt-container label {
      display: block;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #555;
    }

    .system-prompt-container textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .messages {
      flex: 1;
      padding: 12px;
      overflow-y: auto;
      background: #fafafa;
    }

    .message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-radius: 4px;
      max-width: 80%;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.user {
      background: #e9f7ef;
      align-self: flex-end;
    }

    .message.assistant {
      background: #f1f1f1;
      align-self: flex-start;
    }

    .message.system {
      background: #fffbe6;
      border: 1px dashed #ccc;
    }

    .message-form {
      display: flex;
      padding: 12px;
      border-top: 1px solid #ddd;
      background: #f8f9fa;
    }

    .message-form textarea {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      font-size: 0.9rem;
      min-height: 60px;
    }

    .message-form button {
      margin-left: 8px;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      font-size: 0.9rem;
      cursor: pointer;
    }

    .message-form button:hover {
      background: #0056b3;
    }

    .message-form button:disabled {
      background: #94b9e8;
      cursor: not-allowed;
    }

    .message-form textarea:disabled {
      background: #e9ecef;
      cursor: not-allowed;
    }

    .message-form.disabled {
      opacity: 0.7;
    }

    .chat-notice {
      display: none;
      padding: 12px;
      background: #fff3cd;
      border-bottom: 1px solid #f7d070;
      color: #6c4a00;
      font-size: 0.9rem;
    }

    .chat-notice.active {
      display: block;
    }

    .chat-notice ul {
      margin: 0;
      padding-left: 20px;
    }

    /* Loading indicator styling */
    .loading {
      display: inline-block;
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #007bff;
      width: 24px;
      height: 24px;
      animation: spin 1s linear infinite;
    }

    .mobile-toggle {
      border: none;
      background: transparent;
      font-size: 1.6rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px 6px;
      color: #007bff;
    }

    .mobile-toggle:focus,
    .sidebar-close:focus {
      outline: 2px solid #007bff;
      outline-offset: 2px;
    }

    #sidebarOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 1000;
    }

    body.sidebar-open #sidebarOverlay {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 1000;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1001;
    }

    .modal[hidden],
    .modal-backdrop[hidden] {
      display: none !important;
    }

    .modal .sheet {
      width: 100%;
      max-height: 85vh;
      overflow: auto;
      background: #fff;
      border-top-left-radius: 12px;
      border-top-right-radius: 12px;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      box-shadow: 0 -6px 24px rgba(0, 0, 0, 0.2);
      position: relative;
    }

    .modal .modal-close {
      position: absolute;
      right: 16px;
      top: 12px;
      border: none;
      background: transparent;
      font-size: 1.6rem;
      cursor: pointer;
    }

    .modal h2 {
      margin-top: 4px;
    }

    .modal .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 12px 0;
    }

    .modal .cta-link {
      display: inline-block;
      padding: 8px 10px;
      border-radius: 6px;
      background: #f1f3f5;
      color: #0a58ca;
      text-decoration: none;
    }

    .modal .primary,
    .modal .secondary {
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid #ccc;
      cursor: pointer;
      background: #fff;
    }

    .modal .primary {
      background: #0d6efd;
      color: #fff;
      border-color: #0d6efd;
    }

    .modal .secondary {
      background: #fff;
      color: #0d6efd;
      border-color: #0d6efd;
    }

    .modal .fine-print {
      color: #666;
      font-size: 0.85rem;
    }

    @media (min-width: 900px) {
      #app {
        flex-direction: row;
        min-height: 100vh;
      }

      .sidebar {
        position: relative;
        transform: none;
        width: 300px;
        max-width: 300px;
        box-shadow: none;
      }

      body.sidebar-open {
        overflow: auto;
      }

      #sidebarOverlay,
      .mobile-toggle,
      .sidebar-close {
        display: none;
      }

      .chat-area {
        padding-left: 0;
        min-height: 100vh;
      }

      .modal {
        align-items: center;
      }

      .modal .sheet {
        max-width: 720px;
        border-radius: 12px;
        padding: 20px 24px;
      }
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Sidebar containing configuration and thread list -->
    <aside class="sidebar" aria-label="Settings panel" aria-hidden="true">
      <div class="sidebar-header">
        <h2>Settings</h2>
        <button type="button" id="closeSidebarBtn" class="sidebar-close" aria-label="Close settings">×</button>
      </div>
      <div class="form-group">
        <label for="endpointInput">API endpoint</label>
        <input type="text" id="endpointInput" placeholder="https://api.example.com/v1/chat/completions" />
      </div>
      <div class="form-group">
        <label for="modelSelect">Model</label>
        <div class="model-select-row">
          <button type="button" id="refreshModelsBtn">Refresh model list</button>
          <select id="modelSelect"></select>
        </div>
      </div>
      <div class="form-group">
        <label for="tokenInput">API token</label>
        <input type="password" id="tokenInput" placeholder="sk-..." />
      </div>
      <div class="form-group">
        <button id="saveConfigBtn">Save config</button>
      </div>
      <hr />
      <div class="threads-header">
        <h3>Chats</h3>
      </div>
      <ul id="threadList" class="thread-list"></ul>
      <div class="actions">
        <button id="exportBtn">Export history</button>
        <input type="file" id="importInput" accept="application/json" style="display: none;" />
        <button id="importBtn">Import history</button>
        <button id="exportConfigBtn">Export settings</button>
        <input type="file" id="importConfigInput" accept="application/json" style="display: none;" />
        <button id="importConfigBtn">Import settings</button>
      </div>
    </aside>
    <div id="sidebarOverlay" aria-hidden="true"></div>

    <!-- Main chat area -->
    <main class="chat-area">
      <div id="chatHeader" class="chat-header">
        <button type="button" id="openSidebarBtn" class="mobile-toggle" aria-label="Open settings">☰</button>
        <input type="text" id="threadTitleInput" class="thread-title" placeholder="Chat title" />
        <button type="button" id="aboutBtn" class="about-btn" aria-label="About &amp; Privacy">ⓘ</button>
      </div>

      <div id="promoBanner" class="promo-banner" role="region" aria-label="Journal Foundation notice" hidden>
        <span>
          Private local chat demo by
          <a href="https://JournalFoundation.org" target="_blank" rel="noopener">JournalFoundation.org</a>.
          Save this page to run it offline.
        </span>
        <button id="dismissPromoBtn" class="dismiss" aria-label="Dismiss notice">×</button>
      </div>
      <div id="chatNotice" class="chat-notice" role="status" aria-live="polite" hidden></div>
      <div id="systemPromptContainer" class="system-prompt-container">
        <label for="systemPromptInput">System prompt:</label>
        <textarea id="systemPromptInput" placeholder="You are a helpful assistant."></textarea>
      </div>
      <div id="messages" class="messages"></div>
      <form id="messageForm" class="message-form">
        <textarea id="messageInput" placeholder="Type your message" rows="3"></textarea>
        <button type="submit" id="sendBtn">Send</button>
      </form>
    </main>
  </div>

  <script>
    /*
     * Private Chat Client: lightweight local chat UI for chat completion APIs.
     *
     * This implementation is based on PR #2 from the provided options.
     *
     * The script below manages chat threads, configuration, and interactions
     * with external API endpoints. It also enforces availability rules such
     * that a user cannot send a message until a thread is selected and the
     * endpoint and model are configured. Additionally, this version
     * supports pre-populating the chat title, system prompt, and message
     * fields via URL query parameters. See the parseUrlParams() function.
     */

    (() => {
      // DOM element references
      const endpointInput = document.getElementById('endpointInput');
      const tokenInput = document.getElementById('tokenInput');
      const modelSelect = document.getElementById('modelSelect');
      const refreshModelsBtn = document.getElementById('refreshModelsBtn');
      const saveConfigBtn = document.getElementById('saveConfigBtn');
      const threadList = document.getElementById('threadList');
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const importInput = document.getElementById('importInput');
      const exportConfigBtn = document.getElementById('exportConfigBtn');
      const importConfigBtn = document.getElementById('importConfigBtn');
      const importConfigInput = document.getElementById('importConfigInput');
      const openSidebarBtn = document.getElementById('openSidebarBtn');
      const closeSidebarBtn = document.getElementById('closeSidebarBtn');
      const sidebarOverlay = document.getElementById('sidebarOverlay');
      const sidebarEl = document.querySelector('.sidebar');
      const threadTitleInput = document.getElementById('threadTitleInput');
      const systemPromptInput = document.getElementById('systemPromptInput');
      const chatNotice = document.getElementById('chatNotice');
      const messagesEl = document.getElementById('messages');
      const messageForm = document.getElementById('messageForm');
      const messageInput = document.getElementById('messageInput');
      const sendBtn = document.getElementById('sendBtn');
      const aboutBtn = document.getElementById('aboutBtn');
      const promoBanner = document.getElementById('promoBanner');
      const dismissPromoBtn = document.getElementById('dismissPromoBtn');
      const aboutModal = document.getElementById('aboutModal');
      const modalBackdrop = document.getElementById('modalBackdrop');
      const aboutCloseBtn = document.getElementById('aboutCloseBtn');
      const downloadPageBtn = document.getElementById('downloadPageBtn');
      const copyPreloadLinkBtn = document.getElementById('copyPreloadLinkBtn');
      const githubProjectLink = document.getElementById('githubProjectLink');

      // Application state
      let config = {
        endpoint: '',
        token: '',
        model: ''
      };
      let threads = [];
      let currentThreadId = null;
      let models = [];
      let openThreadMenu = null;
      const desktopMediaQuery = window.matchMedia('(min-width: 900px)');

      const defaults = { endpoint: '', token: '', model: '' };
      const CONFIG_KEY = 'chatConfig';
      const THREAD_KEY = 'chatThreads';
      const MODELS_KEY = 'chatModels';

      const readJson = (store, key, fallback) => {
        try {
          const raw = store.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch (err) {
          console.warn(`Could not read ${key}:`, err);
          return fallback;
        }
      };

      const writeJson = (store, key, value) => {
        try {
          store.setItem(key, JSON.stringify(value));
        } catch (err) {
          console.error(`Failed to write ${key}:`, err);
        }
      };

      function openAbout() {
        if (!aboutModal || !modalBackdrop) return;
        aboutModal.hidden = false;
        modalBackdrop.hidden = false;
        document.body.style.overflow = 'hidden';
      }

      function closeAbout() {
        if (!aboutModal || !modalBackdrop) return;
        aboutModal.hidden = true;
        modalBackdrop.hidden = true;
        document.body.style.overflow = '';
      }

      function maybeShowPromo() {
        if (!promoBanner) return;
        const dismissed = sessionStorage.getItem('promoDismissed') === '1';
        promoBanner.hidden = dismissed;
      }

      function buildPreloadUrl() {
        const base = window.location.origin + window.location.pathname;
        const params = new URLSearchParams();
        const titleValue = threadTitleInput?.value?.trim();
        const systemValue = systemPromptInput?.value?.trim();
        const promptValue = messageInput?.value?.trim();
        if (titleValue) params.set('title', titleValue);
        if (systemValue) params.set('system', systemValue);
        if (promptValue) params.set('prompt', promptValue);
        const query = params.toString();
        return query ? `${base}?${query}` : base;
      }

      function initMarketing() {
        maybeShowPromo();
        if (githubProjectLink) {
          const githubMeta = document.querySelector('meta[name="github-url"]');
          const href = githubMeta?.getAttribute('content');
          if (href) {
            githubProjectLink.href = href;
          }
        }
        const qs = new URLSearchParams(window.location.search);
        if (qs.get('about') === '1') {
          openAbout();
        }
      }

      const persistConfig = () => writeJson(sessionStorage, CONFIG_KEY, config);

      function loadModels() {
        models = readJson(sessionStorage, MODELS_KEY, []);
      }

      function storeModels(list) {
        models = [...new Set(list.filter(Boolean))];
        writeJson(sessionStorage, MODELS_KEY, models);
      }

      /**
       * Render the model dropdown. If no models are loaded the select is disabled.
       * @param {string[]} list list of model ids
       * @param {string} desiredModel previously selected model
       */
      function renderModelOptions(list, desiredModel) {
        const ids = [...new Set(list.filter(Boolean))];
        modelSelect.innerHTML = '';
        if (!ids.length) {
          modelSelect.disabled = true;
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'No models loaded';
          modelSelect.appendChild(option);
          if (config.model) {
            config.model = '';
            persistConfig();
          }
          updateChatAvailability();
          return;
        }

        ids.forEach(id => {
          const option = document.createElement('option');
          option.value = id;
          option.textContent = id;
          modelSelect.appendChild(option);
        });

        modelSelect.disabled = false;
        const selection = ids.includes(desiredModel) ? desiredModel : ids[0];
        modelSelect.value = selection;
        if (config.model !== selection) {
          config.model = selection;
          persistConfig();
        }
        updateChatAvailability();
      }

      function loadConfig() {
        config = { ...defaults, ...readJson(sessionStorage, CONFIG_KEY, {}) };
        endpointInput.value = config.endpoint;
        tokenInput.value = config.token;
        renderModelOptions(models, config.model);
      }

      function saveConfig() {
        config = {
          endpoint: endpointInput.value.trim(),
          token: tokenInput.value.trim(),
          model: modelSelect.value.trim()
        };
        persistConfig();
        updateChatAvailability();
        alert('Configuration saved for this session.');
        refreshModels({ silent: true });
      }

      function loadThreads() {
        threads = readJson(localStorage, THREAD_KEY, []);
      }

      function saveThreads() {
        writeJson(localStorage, THREAD_KEY, threads);
      }

      const getThread = id => threads.find(t => t.id === id);
      const currentThread = () => getThread(currentThreadId);
      const updateThread = mutator => {
        const thread = currentThread();
        if (!thread) return null;
        mutator(thread);
        saveThreads();
        return thread;
      };

      /**
       * Derive the state of the chat. A thread, endpoint and model must be selected
       * before sending messages. This helper returns booleans representing those
       * conditions as well as an aggregate "ready" flag.
       */
      function getChatState() {
        const thread = currentThread();
        const hasThread = Boolean(thread);
        const hasEndpoint = Boolean((config.endpoint || '').trim());
        const hasModel = Boolean((config.model || '').trim());
        return {
          hasThread,
          hasEndpoint,
          hasModel,
          ready: hasThread && hasEndpoint && hasModel
        };
      }

      /**
       * Enable or disable the send button depending on whether a message is ready to send.
       * @param {boolean} isReady indicates if chat conditions are met
       */
      function updateSendButtonDisabled(isReady) {
        if (!sendBtn || !messageInput) return;
        const hasContent = Boolean(messageInput.value.trim());
        sendBtn.disabled = !isReady || !hasContent || messageInput.disabled;
      }

      /**
       * Update the notice block above the chat area to indicate missing prerequisites.
       * When there are no issues this hides the notice, otherwise lists guidance.
       * @param {object} state output from getChatState()
       */
      function updateChatNotice(state) {
        if (!chatNotice) return;
        const instructions = [];
        if (!state.hasEndpoint) {
          instructions.push('Enter an API endpoint in Settings to send messages.');
        }
        if (state.hasEndpoint && !state.hasModel) {
          instructions.push('Refresh and select a model before chatting.');
        }
        if (!state.hasThread) {
          instructions.push('Create or select a chat from the sidebar.');
        }

        chatNotice.innerHTML = '';
        if (!instructions.length) {
          chatNotice.classList.remove('active');
          chatNotice.setAttribute('aria-hidden', 'true');
          chatNotice.hidden = true;
          if (messageInput) {
            messageInput.removeAttribute('aria-describedby');
          }
          return;
        }

        const list = document.createElement('ul');
        instructions.forEach(text => {
          const item = document.createElement('li');
          item.textContent = text;
          list.appendChild(item);
        });
        chatNotice.appendChild(list);
        chatNotice.classList.add('active');
        chatNotice.setAttribute('aria-hidden', 'false');
        chatNotice.hidden = false;
        if (messageInput) {
          messageInput.setAttribute('aria-describedby', 'chatNotice');
        }
      }

      /**
       * Based on chat state, enable/disable inputs and update placeholders
       * to guide the user toward completing the necessary steps. When a
       * message has been prefilled via URL, we leave that value intact
       * so the user can see it even if sending is disabled.
       */
      function updateChatAvailability() {
        const state = getChatState();
        const placeholder = !state.hasThread
          ? 'Select or start a chat to enable messaging'
          : !state.hasEndpoint
            ? 'Add an API endpoint to enable messaging'
            : !state.hasModel
              ? 'Select a model to enable messaging'
              : 'Type your message';
        threadTitleInput.disabled = !state.hasThread;
        systemPromptInput.disabled = !state.hasThread;

        // Only update the message placeholder if the input is empty. If there's
        // pre-filled text we leave it alone so that the user can see it.
        if (!messageInput.value) {
          messageInput.placeholder = placeholder;
        }
        // Disable input when not ready, but leave the value alone.
        messageInput.disabled = !state.ready;
        if (state.ready) {
          messageForm.classList.remove('disabled');
          messageForm.setAttribute('aria-disabled', 'false');
        } else {
          messageForm.classList.add('disabled');
          messageForm.setAttribute('aria-disabled', 'true');
        }
        updateChatNotice(state);
        updateSendButtonDisabled(state.ready);
      }

      /**
       * Render the list of chat threads in the sidebar. Each entry is clickable
       * and optionally exposes a menu for renaming or deleting the thread.
       */
      function renderThreadList() {
        closeThreadMenu();
        threadList.innerHTML = '';
        const createLi = document.createElement('li');
        createLi.classList.add('new-thread-item');
        const createBtn = document.createElement('button');
        createBtn.type = 'button';
        createBtn.classList.add('new-thread-button');
        createBtn.textContent = 'Start new chat';
        createBtn.addEventListener('click', event => {
          event.stopPropagation();
          newThread();
        });
        createLi.appendChild(createBtn);
        threadList.appendChild(createLi);
        threads.forEach(thread => {
          const threadName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
          const li = document.createElement('li');
          li.dataset.id = thread.id;
          if (thread.id === currentThreadId) {
            li.classList.add('selected');
          }
          const nameSpan = document.createElement('span');
          nameSpan.classList.add('thread-name');
          nameSpan.textContent = threadName;
          li.appendChild(nameSpan);

          const menuBtn = document.createElement('button');
          menuBtn.type = 'button';
          menuBtn.classList.add('thread-menu-btn');
          menuBtn.setAttribute('aria-label', `Options for ${threadName}`);
          menuBtn.textContent = '⋮';
          menuBtn.addEventListener('click', event => {
            event.stopPropagation();
            toggleThreadMenu(thread.id, menuBtn);
          });
          li.appendChild(menuBtn);

          li.addEventListener('click', () => selectThread(thread.id));
          threadList.appendChild(li);
        });
      }

      /**
       * Select a thread by ID, updating UI and state accordingly. If the
       * thread doesn't exist, the chat inputs are disabled.
       * @param {string} id thread identifier
       */
      function selectThread(id) {
        closeThreadMenu();
        currentThreadId = id;
        const thread = getThread(id);
        if (!thread) {
          updateChatAvailability();
          return;
        }
        // Populate title and system prompt
        threadTitleInput.value = thread.title || '';
        systemPromptInput.value = thread.systemPrompt || '';
        // Render messages
        renderMessages(thread);
        // Re-render thread list to highlight current
        renderThreadList();
        closeSidebar();
        updateChatAvailability();
      }

      /**
       * Create a new chat thread. This generates a unique id and inserts
       * an empty conversation into the list. The new thread becomes the
       * currently selected one.
       */
      function newThread() {
        const id = Date.now().toString();
        threads.push({ id, title: 'New chat', systemPrompt: '', messages: [] });
        saveThreads();
        renderThreadList();
        selectThread(id);
      }

      /**
       * Delete a chat thread by id. After deletion the next available thread
       * becomes current. If none remain, the chat area is cleared and
       * disabled.
       * @param {string} targetId id to delete
       */
      function deleteThread(targetId = currentThreadId) {
        if (!targetId) return;
        const index = threads.findIndex(t => t.id === targetId);
        if (index === -1) return;
        const confirmed = window.confirm('Delete this chat thread?');
        if (!confirmed) return;
        threads.splice(index, 1);
        saveThreads();
        currentThreadId = threads[0]?.id || null;
        if (currentThreadId) {
          selectThread(currentThreadId);
          return;
        }
        threadTitleInput.value = '';
        systemPromptInput.value = '';
        messagesEl.innerHTML = '';
        renderThreadList();
        updateChatAvailability();
      }

      /**
       * Rename the given thread by prompting the user for a new title. The
       * current thread title input updates along with the list.
       * @param {string} threadId id of the thread to rename
       */
      function renameThread(threadId) {
        const thread = getThread(threadId);
        if (!thread) return;
        const currentName = thread.title && thread.title.trim() ? thread.title.trim() : 'Untitled';
        const newName = window.prompt('Rename chat', currentName);
        if (newName === null) return;
        thread.title = newName.trim() || 'Untitled';
        saveThreads();
        renderThreadList();
        if (threadId === currentThreadId) {
          threadTitleInput.value = thread.title;
        }
      }

      /**
       * Render all messages for a given thread. This simply loops over the
       * stored messages and creates elements for each role.
       * @param {object} thread chat thread
       */
      function renderMessages(thread) {
        messagesEl.innerHTML = '';
        thread.messages.forEach(msg => {
          const div = document.createElement('div');
          div.classList.add('message', msg.role);
          div.textContent = msg.content;
          messagesEl.appendChild(div);
        });
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      /**
       * Helper to append a message to the current thread, saving and re-rendering.
       * @param {string} role message role ('user', 'assistant', 'system')
       * @param {string} content message content
       */
      function addMessage(role, content) {
        const thread = updateThread(t => t.messages.push({ role, content }));
        if (thread) {
          renderMessages(thread);
        }
      }

      /**
       * Open the sidebar. Adds a class to the body that triggers the CSS
       * transform and disables page scrolling on mobile.
       */
      function openSidebar() {
        document.body.classList.add('sidebar-open');
        closeThreadMenu();
        if (closeSidebarBtn) {
          setTimeout(() => closeSidebarBtn.focus(), 0);
        }
        updateSidebarAria();
      }

      /**
       * Close the sidebar and optionally restore focus to the hamburger button.
       * @param {object} options options.restoreFocus when true focuses the open button
       */
      function closeSidebar(options = {}) {
        const wasOpen = document.body.classList.contains('sidebar-open');
        if (wasOpen) {
          document.body.classList.remove('sidebar-open');
          if (options.restoreFocus && openSidebarBtn && !desktopMediaQuery.matches) {
            openSidebarBtn.focus({ preventScroll: true });
          }
        }
        updateSidebarAria();
      }

      function updateSidebarAria() {
        if (!sidebarEl) return;
        const hidden = !desktopMediaQuery.matches && !document.body.classList.contains('sidebar-open');
        sidebarEl.setAttribute('aria-hidden', hidden ? 'true' : 'false');
      }

      /**
       * Close the thread action menu if open.
       */
      function closeThreadMenu() {
        if (!openThreadMenu) return;
        document.removeEventListener('mousedown', openThreadMenu.outsideHandler);
        document.removeEventListener('keydown', openThreadMenu.keyHandler);
        if (openThreadMenu.menuEl.parentNode) {
          openThreadMenu.menuEl.parentNode.removeChild(openThreadMenu.menuEl);
        }
        openThreadMenu = null;
      }

      /**
       * Toggle the thread action menu for a given thread. The menu appears
       * anchored to the provided element and is removed when clicking outside
       * or pressing escape.
       * @param {string} threadId id of the thread
       * @param {HTMLElement} anchor element to anchor the menu to
       */
      function toggleThreadMenu(threadId, anchor) {
        if (openThreadMenu && openThreadMenu.anchor === anchor) {
          closeThreadMenu();
          return;
        }
        closeThreadMenu();
        const menu = document.createElement('div');
        menu.classList.add('thread-menu');

        const renameBtn = document.createElement('button');
        renameBtn.textContent = 'Rename';
        renameBtn.addEventListener('click', () => {
          closeThreadMenu();
          renameThread(threadId);
        });
        menu.appendChild(renameBtn);

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.classList.add('delete');
        deleteBtn.addEventListener('click', () => {
          closeThreadMenu();
          deleteThread(threadId);
        });
        menu.appendChild(deleteBtn);

        document.body.appendChild(menu);
        const rect = anchor.getBoundingClientRect();
        menu.style.top = `${window.scrollY + rect.bottom + 4}px`;
        menu.style.left = `${window.scrollX + rect.left}px`;
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = document.documentElement.clientWidth;
        if (menuRect.right > viewportWidth) {
          const adjustedLeft = Math.max(8, viewportWidth - menuRect.width - 8);
          menu.style.left = `${window.scrollX + adjustedLeft}px`;
        }

        const outsideHandler = event => {
          if (menu.contains(event.target) || anchor.contains(event.target)) {
            return;
          }
          closeThreadMenu();
        };
        const keyHandler = event => {
          if (event.key === 'Escape') {
            closeThreadMenu();
          }
        };
        document.addEventListener('mousedown', outsideHandler);
        document.addEventListener('keydown', keyHandler);
        openThreadMenu = {
          menuEl: menu,
          anchor,
          outsideHandler,
          keyHandler
        };
      }

      /**
       * Send the current message to the API. This prevents default form
       * submission behaviour, validates chat readiness and content, then
       * appends the user message, sends the request and appends the reply.
       * It also shows a loading indicator while the API call is in flight.
       * @param {Event} event form submit event
       */
      async function handleSendMessage(event) {
        event.preventDefault();
        const state = getChatState();
        if (!state.ready) {
          updateChatAvailability();
          return;
        }
        const message = messageInput.value.trim();
        if (!message) {
          updateSendButtonDisabled(state.ready);
          return;
        }
        addMessage('user', message);
        messageInput.value = '';
        updateSendButtonDisabled(state.ready);

        // Show loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.classList.add('loading');
        messagesEl.appendChild(loadingIndicator);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        try {
          const reply = await sendToApi();
          addMessage('assistant', reply);
        } catch (err) {
          console.error(err);
          addMessage('system', 'Error: ' + err.message);
        } finally {
          if (loadingIndicator.parentNode) {
            loadingIndicator.parentNode.removeChild(loadingIndicator);
          }
        }
      }

      /**
       * Send the conversation to the configured API endpoint. Uses the current
       * model and thread messages. Throws if required fields are missing or
       * the response status is not ok.
       */
      async function sendToApi() {
        if (!config.endpoint) {
          throw new Error('Endpoint is not configured.');
        }
        const thread = currentThread();
        if (!thread) {
          throw new Error('No thread selected.');
        }
        if (!config.model) {
          throw new Error('Model is not selected.');
        }
        const systemPrompt = thread.systemPrompt?.trim();
        const messagesForRequest = systemPrompt
          ? [{ role: 'system', content: systemPrompt }, ...thread.messages]
          : [...thread.messages];
        // Compose request payload. Adjust this object to match the API expected schema.
        const body = {
          model: config.model,
          messages: messagesForRequest
        };
        const headers = {
          'Content-Type': 'application/json'
        };
        // Include authorization header if token is provided
        if (config.token) {
          headers['Authorization'] = `Bearer ${config.token}`;
        }
        const response = await fetch(config.endpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify(body)
        });
        if (!response.ok) {
          throw new Error('API responded with status ' + response.status);
        }
        // Parse JSON response. We expect a property `choices[0].message.content` similar to OpenAI.
        const data = await response.json();
        const choice = Array.isArray(data?.choices) && data.choices.length ? data.choices[0] : null;
        const reply = choice?.message?.content || choice?.text || (typeof data?.answer === 'string' ? data.answer : '');
        return reply || JSON.stringify(data);
      }

      /**
       * Given an endpoint (possibly relative) derive the URL for the models
       * endpoint. This attempts to find the nearest version segment and
       * replace the trailing path with 'models'.
       * @param {string} endpoint base endpoint
       */
      function deriveModelsUrl(endpoint) {
        let url;
        try {
          url = new URL(endpoint);
        } catch (err) {
          url = new URL(endpoint, window.location.href);
        }
        const segments = url.pathname.split('/').filter(Boolean);
        if (segments[segments.length - 1] === 'models') {
          url.search = '';
          url.hash = '';
          return url.toString();
        }
        const versionIndex = segments.findIndex(seg => /^v\d+$/i.test(seg));
        let baseSegments;
        if (versionIndex !== -1) {
          baseSegments = segments.slice(0, versionIndex + 1);
        } else if (segments.length > 0) {
          baseSegments = segments.slice(0, -1);
        } else {
          baseSegments = [];
        }
        const pathSegments = baseSegments.length ? baseSegments.concat('models') : ['models'];
        url.pathname = '/' + pathSegments.join('/');
        url.search = '';
        url.hash = '';
        return url.toString();
      }

      /**
       * Fetch the list of available models for the current endpoint and token.
       * Updates the dropdown with the returned ids. Silent mode suppresses
       * alerts for invalid endpoints or no models returned.
       * @param {object} opts silent: when true suppresses alert messages
       */
      async function refreshModels({ silent } = {}) {
        const endpoint = endpointInput.value.trim() || config.endpoint;
        if (!endpoint) {
          if (!silent) {
            alert('Set an endpoint before refreshing models.');
          }
          updateChatAvailability();
          return;
        }
        let modelsEndpoint;
        try {
          modelsEndpoint = deriveModelsUrl(endpoint);
        } catch (err) {
          console.error('Invalid endpoint:', err);
          if (!silent) {
            alert('Invalid endpoint: ' + err.message);
          }
          updateChatAvailability();
          return;
        }

        if (config.endpoint !== endpoint) {
          config.endpoint = endpoint;
          persistConfig();
        }

        refreshModelsBtn.disabled = true;
        const originalLabel = refreshModelsBtn.textContent;
        refreshModelsBtn.textContent = 'Loading...';
        try {
          const headers = { Accept: 'application/json' };
          const token = tokenInput.value.trim() || config.token;
          if (token) {
            headers['Authorization'] = `Bearer ${token}`;
            if (config.token !== token) {
              config.token = token;
              persistConfig();
            }
          }
          const response = await fetch(modelsEndpoint, { method: 'GET', headers });
          if (!response.ok) {
            throw new Error('Status ' + response.status);
          }
          const data = await response.json();
          const rawList = Array.isArray(data?.data)
            ? data.data
            : Array.isArray(data?.models)
              ? data.models
              : [];
          const ids = rawList
            .map(item => {
              if (typeof item === 'string') return item.trim();
              if (item && typeof item.id === 'string') return item.id.trim();
              if (item && typeof item.name === 'string') return item.name.trim();
              return '';
            })
            .filter(id => id.length > 0);
          if (!ids.length) {
            throw new Error('No models returned.');
          }
          storeModels(ids);
          renderModelOptions(models, config.model);
          if (!silent) {
            alert('Models updated.');
          }
        } catch (err) {
          console.error('Failed to refresh models:', err);
          if (!silent) {
            alert('Failed to load models: ' + err.message);
          }
        } finally {
          refreshModelsBtn.disabled = false;
          refreshModelsBtn.textContent = originalLabel;
          updateChatAvailability();
        }
      }

      /**
       * Export chat history to a JSON file. The user can download their
       * threads array as a structured JSON document.
       */
      function exportHistory() {
        const dataStr = JSON.stringify(threads, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-history.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      /**
       * Import chat history from a selected JSON file. The file is parsed
       * and, if valid, replaces the current threads list. Afterwards the
       * first thread is selected or the chat area is disabled if none.
       * @param {Event} event input change event
       */
      function importHistory(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imported = JSON.parse(e.target.result);
            if (Array.isArray(imported)) {
              threads = imported;
              saveThreads();
              renderThreadList();
              if (threads.length) {
                selectThread(threads[0].id);
              } else {
                currentThreadId = null;
                updateChatAvailability();
              }
              alert('Import successful');
            } else {
              alert('Invalid file format.');
            }
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
          // Reset input to allow re-importing same file later
          importInput.value = '';
        };
        reader.readAsText(file);
      }

      /**
       * Export the current config and model list to a JSON file. Includes
       * an exportedAt timestamp for reference.
       */
      function exportConfig() {
        const payload = {
          config: { ...config },
          models: [...models],
          exportedAt: new Date().toISOString()
        };
        const dataStr = JSON.stringify(payload, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'chat-config.json';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }

      function normalizeConfig(raw) {
        if (!raw || typeof raw !== 'object') return null;
        return {
          endpoint: typeof raw.endpoint === 'string' ? raw.endpoint : '',
          token: typeof raw.token === 'string' ? raw.token : '',
          model: typeof raw.model === 'string' ? raw.model : ''
        };
      }

      /**
       * Import a configuration file. Extracts config and model list and
       * updates session storage accordingly. Will override current session
       * config but not modify saved threads.
       * @param {Event} event input change event
       */
      function importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
          try {
            const imported = JSON.parse(e.target.result);
            const source = imported && typeof imported === 'object'
              ? (imported.config && typeof imported.config === 'object' ? imported.config : imported)
              : null;
            const nextConfig = normalizeConfig(source);
            if (!nextConfig) {
              alert('Invalid config file.');
              return;
            }
            config = { ...defaults, ...nextConfig };
            persistConfig();
            endpointInput.value = config.endpoint;
            tokenInput.value = config.token;
            if (Array.isArray(imported?.models)) {
              storeModels(imported.models);
            }
            renderModelOptions(models, config.model);
            alert('Configuration imported.');
          } catch (err) {
            alert('Failed to import config: ' + err.message);
          }
          importConfigInput.value = '';
        };
        reader.readAsText(file);
      }

      /**
       * Parse the current URL's query parameters and, if any chat data is
       * provided, prepopulate a new chat thread. Supported parameters:
       *
       *   - title: the chat title
       *   - system: the system prompt
       *   - prompt: the initial message to prefill in the message input
       *
       * If at least one of these parameters is present, a new thread is
       * created (without altering existing ones) and selected. The chat
       * remains disabled until the user configures an endpoint and model.
       */
      function parseUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const titleParam = params.get('title') || params.get('chat') || params.get('name');
        const systemParam = params.get('system') || params.get('systemPrompt') || params.get('system_prompt');
        const promptParam = params.get('prompt') || params.get('message') || params.get('msg');
        // Only act if at least one parameter is present and no threads yet created via params
        if (titleParam || systemParam || promptParam) {
          // Create a new thread with provided values
          const id = Date.now().toString();
          const threadObj = {
            id,
            title: titleParam ? decodeURIComponent(titleParam) : 'New chat',
            systemPrompt: systemParam ? decodeURIComponent(systemParam) : '',
            messages: []
          };
          threads.push(threadObj);
          saveThreads();
          currentThreadId = id;
          // Insert into UI
          renderThreadList();
          selectThread(id);
          // Overwrite fields with decoded values
          threadTitleInput.value = threadObj.title;
          systemPromptInput.value = threadObj.systemPrompt;
          if (promptParam) {
            messageInput.value = decodeURIComponent(promptParam);
          }
          updateChatAvailability();
        }
      }

      /**
       * Initialize the application. Loads persisted models, config and threads
       * from storage, handles URL-based prepopulation, renders the thread
       * list and selects the first available thread. Also refreshes models
       * silently if an endpoint is provided without cached models.
       */
      function init() {
        loadModels();
        loadConfig();
        loadThreads();
        // Check if URL contains chat data and create a thread accordingly
        parseUrlParams();
        renderThreadList();
        // If a thread was created via URL params select it; otherwise pick the first existing
        if (currentThreadId) {
          selectThread(currentThreadId);
        } else {
          const firstThread = threads[0];
          if (firstThread) {
            selectThread(firstThread.id);
          } else {
            updateChatAvailability();
          }
        }
        if (!models.length && config.endpoint) {
          refreshModels({ silent: true });
        }
      }
      init();
      initMarketing();

      // Attach event listeners
      refreshModelsBtn.addEventListener('click', () => refreshModels());
      modelSelect.addEventListener('change', () => {
        config.model = modelSelect.value;
        persistConfig();
        updateChatAvailability();
      });
      saveConfigBtn.addEventListener('click', saveConfig);
      messageForm.addEventListener('submit', handleSendMessage);
      messageInput.addEventListener('input', () => {
        updateSendButtonDisabled(getChatState().ready);
      });
      exportBtn.addEventListener('click', exportHistory);
      importBtn.addEventListener('click', () => importInput.click());
      importInput.addEventListener('change', importHistory);
      exportConfigBtn.addEventListener('click', exportConfig);
      importConfigBtn.addEventListener('click', () => importConfigInput.click());
      importConfigInput.addEventListener('change', importConfig);
      if (aboutBtn) {
        aboutBtn.addEventListener('click', openAbout);
      }
      if (aboutCloseBtn) {
        aboutCloseBtn.addEventListener('click', () => closeAbout());
      }
      if (modalBackdrop) {
        modalBackdrop.addEventListener('click', closeAbout);
      }
      if (dismissPromoBtn) {
        dismissPromoBtn.addEventListener('click', () => {
          sessionStorage.setItem('promoDismissed', '1');
          maybeShowPromo();
        });
      }
      if (downloadPageBtn) {
        downloadPageBtn.addEventListener('click', () => {
          try {
            const html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;
            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const anchor = document.createElement('a');
            anchor.href = url;
            anchor.download = 'private-chat.html';
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);
            URL.revokeObjectURL(url);
          } catch (err) {
            console.error('Failed to download page:', err);
            alert('If download is blocked by your browser, use “Save Page As…” instead.');
          }
        });
      }
      if (copyPreloadLinkBtn) {
        copyPreloadLinkBtn.addEventListener('click', async () => {
          const url = buildPreloadUrl();
          try {
            await navigator.clipboard.writeText(url);
            const original = copyPreloadLinkBtn.textContent;
            copyPreloadLinkBtn.textContent = 'Copied!';
            setTimeout(() => {
              copyPreloadLinkBtn.textContent = original;
            }, 1200);
          } catch (err) {
            console.warn('Clipboard unavailable, fallback to prompt.', err);
            window.prompt('Copy this link:', url);
          }
        });
      }
      if (openSidebarBtn) {
        openSidebarBtn.addEventListener('click', openSidebar);
      }
      if (closeSidebarBtn) {
        closeSidebarBtn.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      if (sidebarOverlay) {
        sidebarOverlay.addEventListener('click', () => closeSidebar({ restoreFocus: true }));
      }
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape') {
          if (aboutModal && !aboutModal.hidden) {
            closeAbout();
            return;
          }
          if (document.body.classList.contains('sidebar-open')) {
            closeSidebar({ restoreFocus: true });
            return;
          }
          closeThreadMenu();
        }
      });
      const handleViewportChange = event => {
        if (event.matches) {
          closeSidebar();
        }
        updateSidebarAria();
      };
      if (desktopMediaQuery.addEventListener) {
        desktopMediaQuery.addEventListener('change', handleViewportChange);
      } else if (desktopMediaQuery.addListener) {
        desktopMediaQuery.addListener(handleViewportChange);
      }
      updateSidebarAria();

      threadTitleInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.title = threadTitleInput.value.trim() || 'Untitled';
          renderThreadList();
        });
      });
      systemPromptInput.addEventListener('blur', () => {
        updateThread(thread => {
          thread.systemPrompt = systemPromptInput.value.trim();
        });
      });
    })();
  </script>
  <div id="modalBackdrop" class="modal-backdrop" hidden></div>
  <div id="aboutModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="aboutTitle" hidden>
    <div class="sheet" role="document">
      <button type="button" class="modal-close" id="aboutCloseBtn" aria-label="Close">×</button>
      <h2 id="aboutTitle">Private &amp; Local — About this demo</h2>
      <p><strong>This is a single static HTML file.</strong> There is no backend, no database, and nothing on a server to capture your data. Your chats are stored in your browser.</p>

      <h3>How to run it anywhere</h3>
      <ul>
        <li><strong>Desktop:</strong> Right-click → <em>Save Page As…</em>, then open the saved file.</li>
        <li><strong>iPhone (Safari):</strong> Share → <em>Add to Home Screen</em>, or Share → <em>Save to Files</em>, then open it.</li>
      </ul>

      <h3>What’s stored locally</h3>
      <ul>
        <li><code>localStorage</code>: chat threads and messages.</li>
        <li><code>sessionStorage</code>: settings (endpoint, token, models) for the current session.</li>
      </ul>
      <p>No network calls happen unless you set an API endpoint and press <em>Send</em> (or <em>Refresh model list</em>).</p>

      <div class="cta-row">
        <a id="jfSiteLink" class="cta-link" href="https://JournalFoundation.org" target="_blank" rel="noopener">JournalFoundation.org</a>
        <a id="githubProjectLink" class="cta-link" href="https://github.com/Journal-Foundation/privatelocalchat" target="_blank" rel="noopener">Fork / contribute on GitHub</a>
      </div>

      <div class="cta-row">
        <button id="downloadPageBtn" class="primary">Download this page</button>
        <button id="copyPreloadLinkBtn" class="secondary">Copy link with current title/system/prompt</button>
      </div>

      <p class="fine-print">
        Tip: You can also open this dialog directly with <code>?about=1</code> in the URL.
      </p>
    </div>
  </div>
</body>
</html>
